// Generated by LiveScript 1.6.0
(function(){
  var ref$, map, split, filter, find, foldl, drop, take, sum, unique, pairsToObj, sortBy, reverse, each, findIndex, div, times, plus, minus, roundHuman, get, velasWeb3, getTransactionInfo, down, SIMULATION_COUNT, EPOCHS_PER_YEAR, VALIDATOR_COUNT, asCallback, getStakesFromStakesAccounts, fillPools, loadValidatorsFromCache, queryPoolsWeb3t, queryPools, fillDelegators, fillDelegator, queryAccounts, updateLoaderVar, addStakeAccount, filterPools, updateStakeAccount, subscribeToStakeAccount, highlight, queryAccountsWeb3t, fillAccounts, convertAccountsToViewModel, convertPoolsToViewModel, checkTxConfirmation, checkTx, creationAccountSubscribe, searchNewAccount, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};
  ref$ = require('prelude-ls'), map = ref$.map, split = ref$.split, filter = ref$.filter, find = ref$.find, foldl = ref$.foldl, drop = ref$.drop, take = ref$.take, sum = ref$.sum, unique = ref$.unique, pairsToObj = ref$.pairsToObj, sortBy = ref$.sortBy, reverse = ref$.reverse, each = ref$.each, findIndex = ref$.findIndex;
  ref$ = require('./math.ls'), div = ref$.div, times = ref$.times, plus = ref$.plus, minus = ref$.minus;
  roundHuman = require('./round-human.ls');
  get = require('../web3t/providers/superagent.js').get;
  velasWeb3 = require('../web3t/providers/solana/index.cjs');
  getTransactionInfo = require('./api.ls').getTransactionInfo;
  down = function(it){
    return (it != null ? it : "").toLowerCase();
  };
  SIMULATION_COUNT = 14600;
  EPOCHS_PER_YEAR = 1460;
  VALIDATOR_COUNT = 19;
  asCallback = function(p, cb){
    p['catch'](function(err){
      return cb(err);
    });
    return p.then(function(data){
      return cb(null, data);
    });
  };
  getStakesFromStakesAccounts = function(store, item){
    var found, stakes;
    found = filter(function(it){
      return +it.activationEpoch < +it.deactivationEpoch && (it != null ? it.voter : void 8) === item.key;
    })(
    store.staking.accounts);
    stakes = (function(){
      switch (false) {
      case !(found.length > 0):
        return map(function(it){
          return {
            seed: it.seed,
            item: it,
            stake: it.stake
          };
        })(
        found);
      default:
        return [];
      }
    }());
    return stakes;
  };
  fillPools = function(arg$, onFinish, arg1$){
    var store, web3t, onProgress, item, rest, ref$, stakes, onFinishLocal, onProgressLocal;
    store = arg$.store, web3t = arg$.web3t, onProgress = arg$.onProgress;
    item = arg1$[0], rest = slice$.call(arg1$, 1);
    if (item == null) {
      store.staking.allPoolsLoaded = true;
      store.staking.poolsAreLoading = false;
      return onFinish(null, []);
    }
    if (['validators', 'info', 'account_details', 'poolchoosing', 'pool_details'].indexOf(store.current.page) === -1) {
      store.staking.allPoolsLoaded = false;
      store.staking.poolsAreLoading = false;
      return onFinish(null, []);
    }
    item.activatedStake = item.activatedStake;
    item.balanceRaw = item.activatedStake;
    item.address = item.key;
    item.stake = item.stake;
    item.stakeInitial = item.activatedStake;
    item.status = status;
    item.commission = item.commission;
    item.credits_observed = foldl(plus, 0)(
    map(function(it){
      return it[1];
    })(
    item.epochCredits));
    item.delegators = (ref$ = store.staking.delegators[down(item.votePubkey)]) != null ? ref$ : 0;
    stakes = getStakesFromStakesAccounts(store, item);
    item.stakes = stakes;
    if (onProgress != null) {
      onProgress([item].concat(arrayFrom$(rest)));
    }
    onFinishLocal = function(err, pools){
      return onFinish(err, [item].concat(arrayFrom$(pools)));
    };
    onProgressLocal = function(pools){
      return onProgress([item].concat(arrayFrom$(pools)));
    };
    return fillPools({
      store: store,
      web3t: web3t,
      onProgress: onProgressLocal
    }, onFinishLocal, rest);
  };
  loadValidatorsFromCache = function(arg$, cb){
    var store, web3t, DEADLINE, lastTime, ref$, now, network, cachedNetwork, cacheResult;
    store = arg$.store, web3t = arg$.web3t;
    DEADLINE = 60000;
    lastTime = (ref$ = store.staking.lastTime) != null
      ? ref$
      : new Date().getTime();
    now = new Date().getTime();
    network = store.current.network;
    cachedNetwork = store.staking.cachedValidatorsNetwork;
    if (minus(now, lastTime) <= DEADLINE && store.staking.cachedValidators != null && store.staking.cachedValidators.length) {
      if (cachedNetwork === network) {
        cacheResult = store.staking.cachedValidators;
        return cb(null, cacheResult);
      }
    }
    return asCallback(web3t.velas.NativeStaking.getStakingValidators(), function(err, validators){
      if (err != null) {
        console.error("GetStakingValidators err: ", err);
      }
      if (err != null) {
        return cb(err);
      }
      store.staking.cachedValidators = validators;
      store.staking.cachedValidatorsNetwork = network;
      store.staking.lastTime = new Date().getTime();
      return cb(null, validators);
    });
  };
  queryPoolsWeb3t = function(arg$, onFinish){
    var store, web3t, onProgress;
    store = arg$.store, web3t = arg$.web3t, onProgress = arg$.onProgress;
    return loadValidatorsFromCache({
      store: store,
      web3t: web3t
    }, function(err, validators){
      if (err != null) {
        return onFinish(err);
      }
      store.staking.totalValidators = validators.length;
      store.staking.poolsAreLoading = true;
      return fillPools({
        store: store,
        web3t: web3t,
        onProgress: onProgress
      }, onFinish, validators);
    });
  };
  queryPools = function(arg$, onFinish){
    var store, web3t, onProgress;
    store = arg$.store, web3t = arg$.web3t, onProgress = arg$.onProgress;
    fillDelegators(store, web3t);
    return queryPoolsWeb3t({
      store: store,
      web3t: web3t,
      onProgress: onProgress
    }, function(err, pools){
      if (err != null) {
        return onFinish(err);
      }
      return onFinish(null, pools);
    });
  };
  fillDelegators = function(store, web3t){
    var accounts;
    accounts = store.staking.parsedProgramAccounts;
    return Array.from(accounts, fillDelegator(store, web3t));
  };
  fillDelegator = curry$(function(store, web3t, acc){
    var voter, activationEpoch, deactivationEpoch;
    if (acc == null) {
      return;
    }
    voter = acc.voter, activationEpoch = acc.activationEpoch, deactivationEpoch = acc.deactivationEpoch;
    if (voter && (Number(deactivationEpoch) > Number(activationEpoch) || activationEpoch === web3t.velas.NativeStaking.max_epoch)) {
      return store.staking.delegators[down(voter)] = store.staking.delegators[down(voter)] != null ? store.staking.delegators[down(voter)] + 1 : 1;
    }
  });
  queryAccounts = function(store, web3t, onProgress, onFinish){
    var accountIndex, network, cachedNetwork;
    accountIndex = store.current.accountIndex;
    network = store.current.network;
    cachedNetwork = store.staking.cachedAccountsNetwork;
    if (store.staking.getAccountsFromCashe === true && store.staking.accountsCached[accountIndex] != null && store.staking.accountsCached[accountIndex].length > 0) {
      if (cachedNetwork === network) {
        store.staking.allAccountsLoaded = true;
        store.staking.accountsAreLoading = false;
        return onFinish(null, store.staking.accountsCached[accountIndex]);
      }
    }
    return queryAccountsWeb3t(store, web3t, onProgress, function(err, accounts){
      if (err != null) {
        return onFinish(err);
      }
      store.staking.accountsCached[accountIndex] = accounts;
      store.staking.cachedAccountsNetwork = network;
      return onFinish(err, accounts);
    });
  };
  updateLoaderVar = function(store, config, value){
    if (value !== 'yes' && value !== 'no') {
      return;
    }
    if (config == null) {
      return;
    }
    if (store == null) {
      return;
    }
    if (config.acc_type === 'split') {
      store.staking.splittingStakingAccount = value;
    }
    if (config.acc_type === 'create') {
      store.staking.creatingStakingAccount = value;
    }
  };
  addStakeAccount = function(store, web3t, txInfo, config, onProgress, onFinish){
    var accounts, acc_type, ref$, ref1$, instructions, ref2$, ref3$, seed, ref4$, ref5$, ref6$, info, stakeAccount, alreadyExists, staker, lamports, custodian, activationEpoch, deactivationEpoch, balanceRaw, pubKey, account;
    console.log("[add-stake-account]");
    accounts = store.staking.accounts;
    acc_type = config.acc_type;
    if (acc_type !== 'split' && acc_type !== 'create') {
      return onFinish("Unknown type for acc_type");
    }
    updateLoaderVar(store, config, true);
    instructions = (txInfo != null ? (ref$ = txInfo.data) != null ? (ref1$ = ref$.transaction) != null ? ref1$.message : void 8 : void 8 : void 8).instructions;
    if (((ref2$ = instructions[0]) != null ? (ref3$ = ref2$.parsed) != null ? ref3$.type : void 8 : void 8) !== "createAccountWithSeed") {
      updateLoaderVar(store, config, false);
      return onFinish("Not expected transaction type. Expected 'createAccountWithSeed' type.");
    }
    seed = instructions != null ? (ref4$ = instructions[0]) != null ? (ref5$ = ref4$.parsed) != null ? (ref6$ = ref5$.info) != null ? ref6$.seed : void 8 : void 8 : void 8 : void 8;
    info = (function(){
      var ref$, ref1$, ref2$, ref3$;
      switch (false) {
      case acc_type !== 'split':
        return instructions != null ? (ref$ = instructions[1]) != null ? (ref1$ = ref$.parsed) != null ? ref1$.info : void 8 : void 8 : void 8;
      default:
        return instructions != null ? (ref2$ = instructions[0]) != null ? (ref3$ = ref2$.parsed) != null ? ref3$.info : void 8 : void 8 : void 8;
      }
    }());
    stakeAccount = (function(){
      switch (false) {
      case acc_type !== 'split':
        return info != null ? info.newSplitAccount : void 8;
      default:
        return info != null ? info.newAccount : void 8;
      }
    }());
    /* Avoid duplicates of stake accounts on UI */
    alreadyExists = find(function(it){
      return it.pubkey === stakeAccount;
    })(
    store.staking.parsedProgramAccounts);
    if (alreadyExists != null) {
      console.error("acc already exists");
      return;
    }
    staker = (function(){
      switch (false) {
      case acc_type !== 'split':
        return info != null ? info.stakeAuthority : void 8;
      default:
        return info != null ? info.source : void 8;
      }
    }());
    lamports = info != null ? info.lamports : void 8;
    custodian = staker;
    activationEpoch = config.activationEpoch, deactivationEpoch = config.deactivationEpoch;
    balanceRaw = minus(lamports, '2282880');
    pubKey = new velasWeb3.PublicKey(stakeAccount);
    account = {
      activationEpoch: activationEpoch,
      address: stakeAccount,
      balanceRaw: balanceRaw,
      balance: Math.round(div(balanceRaw, Math.pow(10, 9))),
      creditsObserved: 0,
      credits_observed: 0,
      custodian: custodian,
      deactivationEpoch: deactivationEpoch,
      epoch: 0,
      key: stakeAccount,
      lamports: lamports,
      pubkey: stakeAccount,
      pubKey: pubKey,
      rent: div("2282880", Math.pow(10, 9)),
      rentRaw: "2282880",
      rentExemptReserve: "2282880",
      seed: "stake:" + seed,
      seedIndex: seed,
      staker: staker,
      status: 'loading',
      voter: config.voter,
      validator: config.voter,
      withdrawer: staker,
      highlight: true
    };
    store.staking.parsedProgramAccounts.push(account);
    return asCallback(web3t.velas.NativeStaking.getOwnStakingAccounts(store.staking.parsedProgramAccounts), function(err, accs){
      if (err != null) {
        updateLoaderVar(store, config, false);
        return onFinish(err);
      }
      web3t.velas.NativeStaking.setAccounts(accs);
      store.staking.accounts.push(account);
      updateLoaderVar(store, config, false);
      /* Subscribe to the changes of created stake account */
      each(function(it){
        var publicKey;
        publicKey = it.pubKey;
        return subscribeToStakeAccount({
          store: store,
          web3t: web3t,
          account: it,
          publicKey: pubKey
        });
      })(
      filter(function(a){
        return a.address === stakeAccount;
      })(
      store.staking.accounts));
      searchNewAccount(store, stakeAccount);
      return onFinish(null);
    });
  };
  filterPools = function(pools){
    var delinquent, running;
    store.staking.pools = sortBy(function(it){
      return it.myStake.length;
    })(
    convertPoolsToViewModel(pools));
    delinquent = filter(function(it){
      return it.status === "delinquent";
    })(
    store.staking.pools);
    running = reverse(
    filter(function(it){
      return delinquent.indexOf(it) < 0;
    })(
    store.staking.pools));
    return store.staking.pools = running.concat(delinquent);
  };
  updateStakeAccount = function(arg$){
    var store, account, updatedAccount, cb, lamports, data, ref$, index, ref1$, ref2$, meta, stake, lockup, rentExemptReserve, authorized, creditsObserved, delegation, activationEpoch, deactivationEpoch, voter, updates, onProgress;
    store = arg$.store, account = arg$.account, updatedAccount = arg$.updatedAccount, cb = arg$.cb;
    updateStakeAccount[account.pubkey] = account.pubkey;
    console.log("updateStakeAccount", {
      account: account,
      updatedAccount: updatedAccount
    });
    if (account == null) {
      updateStakeAccount[account.pubkey] = null;
      console.log("No account was found");
      return;
    }
    lamports = updatedAccount.lamports, data = updatedAccount.data;
    if (!(data != null && ((ref$ = data.parsed) != null && ref$.info))) {
      index = findIndex(function(it){
        return it.pubkey === account.pubkey;
      })(
      store.staking.accounts);
      if (index > -1) {
        store.staking.accounts.splice(index, 1);
      }
    } else {
      ref2$ = data != null ? (ref1$ = data.parsed) != null ? ref1$.info : void 8 : void 8, meta = ref2$.meta, stake = ref2$.stake;
      lockup = meta.lockup, rentExemptReserve = meta.rentExemptReserve, authorized = meta.authorized;
      creditsObserved = stake != null ? stake.creditsObserved : void 8;
      delegation = stake != null ? stake.delegation : void 8;
      activationEpoch = (ref2$ = delegation != null ? delegation.activationEpoch : void 8) != null ? ref2$ : 0;
      deactivationEpoch = (ref2$ = delegation != null ? delegation.deactivationEpoch : void 8) != null ? ref2$ : 0;
      stake = (ref2$ = delegation != null ? delegation.stake : void 8) != null ? ref2$ : 0;
      voter = (ref2$ = delegation != null ? delegation.voter : void 8) != null ? ref2$ : null;
      updates = {
        lamports: updatedAccount.lamports,
        stake: stake,
        validator: voter,
        voter: voter,
        rentExemptReserve: rentExemptReserve,
        creditsObserved: creditsObserved,
        activationEpoch: activationEpoch,
        deactivationEpoch: deactivationEpoch
      };
      importAll$(account, updates);
    }
    onProgress = function(it){
      return store.staking.pools = convertPoolsToViewModel(arrayFrom$(it));
    };
    return queryPools({
      store: store,
      web3t: web3t,
      onProgress: onProgress
    }, function(err, pools){
      if (err != null) {
        return cb(err);
      }
      return filterPools(pools);
    });
  };
  /* If find set to true, then we first found account from store.staking.accounts by publicKey */
  subscribeToStakeAccount = function(arg$){
    var store, web3t, account, publicKey, find, cb, commitment, callback, subscriptionID;
    store = arg$.store, web3t = arg$.web3t, account = arg$.account, publicKey = arg$.publicKey, find = arg$.find, cb = arg$.cb;
    if (account.subscriptionID != null) {
      if (cb != null) {
        return cb(null);
      }
      return;
    }
    commitment = 'confirmed';
    callback = function(updatedAccount){
      return updateStakeAccount({
        store: store,
        account: account,
        updatedAccount: updatedAccount,
        cb: cb
      });
    };
    subscriptionID = web3t.velas.NativeStaking.connection.onAccountChange(publicKey, callback, commitment);
    account.subscriptionID = subscriptionID;
    return store.staking.subscribedAccounts[account.pubkey] = true;
  };
  highlight = function(store, AccountIndex){
    if (store.staking.accounts[AccountIndex] == null) {
      return;
    }
    return setTimeout(function(){
      return store.staking.accounts[AccountIndex].highlight = false;
    }, 6500);
  };
  queryAccountsWeb3t = function(store, web3t, onProgress, onFinish){
    var nativeWallet, validatorsBackend;
    nativeWallet = find(function(it){
      return it.coin.token === "vlx_native";
    })(
    store.current.account.wallets);
    validatorsBackend = nativeWallet.network.api.validatorsBackend + '/v1/staking-accounts';
    return get(validatorsBackend).end(function(err, data){
      var nativeAccountsFromBackendResult, ref$, ref1$, parsedProgramAccounts;
      if (err != null) {
        console.log("[get validatorsBackend err]", err);
      }
      if (err != null) {
        return onFinish(err);
      }
      nativeAccountsFromBackendResult = (ref$ = data != null ? (ref1$ = data.body) != null ? ref1$.stakingAccounts : void 8 : void 8) != null
        ? ref$
        : [];
      if (err != null) {
        console.error("[query-accounts-web3t] get parsedProgramAccounts err:", err);
      }
      parsedProgramAccounts = nativeAccountsFromBackendResult != null
        ? nativeAccountsFromBackendResult
        : [];
      store.staking.parsedProgramAccounts = parsedProgramAccounts;
      return asCallback(web3t.velas.NativeStaking.getOwnStakingAccounts(parsedProgramAccounts), function(err, accs){
        if (err != null) {
          accs = [];
        }
        web3t.velas.NativeStaking.setAccounts(accs);
        store.staking.totalOwnStakingAccounts = accs.length;
        if (err != null) {
          return onFinish(err);
        }
        store.staking.accountsAreLoading = true;
        return fillAccounts({
          store: store,
          web3t: web3t,
          onProgress: onProgress,
          onFinish: onFinish
        }, accs);
      });
    });
  };
  fillAccounts = function(arg$, arg1$){
    var store, web3t, onProgress, onFinish, item, rest, rent;
    store = arg$.store, web3t = arg$.web3t, onProgress = arg$.onProgress, onFinish = arg$.onFinish;
    item = arg1$[0], rest = slice$.call(arg1$, 1);
    if (item == null) {
      store.staking.allAccountsLoaded = true;
      store.staking.accountsAreLoading = false;
      return onFinish(null, []);
    }
    if (['validators', 'info', 'account_details', 'pool_details'].indexOf(store.current.page) === -1) {
      store.staking.allAccountsLoaded = false;
      store.staking.accountsAreLoading = false;
      return onFinish(null, []);
    }
    store.staking.loadingAccountIndex += 1;
    rent = item != null ? item.rentExemptReserve : void 8;
    return asCallback(web3t.velas.NativeStaking.checkSeed(item.pubkey), function(err, seed){
      var ref$, activationEpoch, deactivationEpoch, voter, onFinishLocal, onProgressLocal;
      item.seed = seed;
      item.seedIndex = +(item.seed + "").split(":")[1];
      item.address = item.pubkey;
      item.pubKey = new velasWeb3.PublicKey(item.pubkey);
      item.key = item.pubkey;
      item.rentRaw = rent;
      item.balanceRaw = rent != null ? minus(item.lamports, rent) : '-';
      item.balance = rent != null ? div(times(Math.round(div(minus(item.lamports, rent), Math.pow(10, 9))), 100), 100) : "-";
      item.rent = rent != null ? div(rent, Math.pow(10, 9)) : "-";
      item.credits_observed = (ref$ = item.creditsObserved) != null ? ref$ : 0;
      item.status = "inactive";
      item.validator = item.voter;
      activationEpoch = item.activationEpoch, deactivationEpoch = item.deactivationEpoch, voter = item.voter;
      if (activationEpoch && deactivationEpoch) {
        if (Number(deactivationEpoch) > Number(activationEpoch) || Number(activationEpoch) === web3t.velas.NativeStaking.max_epoch) {
          item.status = "loading";
          item.validator = voter;
        }
      }
      if (onProgress != null) {
        onProgress([item].concat(arrayFrom$(rest)));
      }
      onFinishLocal = function(err, pools){
        return onFinish(err, [item].concat(arrayFrom$(pools)));
      };
      onProgressLocal = function(pools){
        return onProgress([item].concat(arrayFrom$(pools)));
      };
      return fillAccounts({
        store: store,
        web3t: web3t,
        onProgress: onProgressLocal,
        onFinish: onFinishLocal
      }, rest);
    });
  };
  convertAccountsToViewModel = function(accounts){
    var res;
    res = map(function(it){
      var ref$;
      return {
        address: (ref$ = it.key) != null ? ref$ : '..',
        activationEpoch: it.activationEpoch,
        deactivationEpoch: it.deactivationEpoch,
        key: it.key,
        pubKey: it.pubKey,
        balanceRaw: (ref$ = it.balanceRaw) != null ? ref$ : 0,
        balance: it.balance != null ? roundHuman(it.balance) : '..',
        rent: it.rent != null ? it.rent : "-",
        lastVote: (ref$ = it.lastVote) != null ? ref$ : '..',
        seed: (ref$ = it.seed) != null ? ref$ : '..',
        validator: (ref$ = it != null ? it.validator : void 8) != null ? ref$ : "",
        status: (ref$ = it.status) != null ? ref$ : "inactive",
        active_stake: (ref$ = it != null ? it.active_stake : void 8) != null ? ref$ : 0,
        inactive_stake: (ref$ = it != null ? it.inactive_stake : void 8) != null ? ref$ : 0,
        seedIndex: it.seedIndex,
        credits_observed: it.credits_observed,
        voter: it.voter
      };
    })(
    accounts);
    return res;
  };
  convertPoolsToViewModel = function(pools){
    return map(function(it){
      var ref$;
      return {
        address: (ref$ = it.key) != null ? ref$ : '..',
        balanceRaw: it.activatedStake,
        checked: false,
        stake: it.stake != null ? it.stake : '..',
        stakeInitial: it.activatedStake != null ? parseFloat(div(it.activatedStake, Math.pow(10, 9))) : 0,
        commission: it.commission,
        lastVote: it.lastVote ? roundHuman(it.lastVote) : '..',
        stakers: it.delegators != null ? it.delegators : '..',
        isValidator: (ref$ = (it != null ? it.stakes : void 8) != null && it.stakes.length !== 0) != null ? ref$ : false,
        status: (it != null ? it.delinquent : void 8) === true
          ? "delinquent"
          : it.status,
        myStake: it != null && it.stakes
          ? it.stakes
          : [],
        credits_observed: it.credits_observed
      };
    })(
    pools);
  };
  checkTxConfirmation = function(arg$, cb){
    var start, network, tx;
    start = arg$.start, network = arg$.network, tx = arg$.tx;
    return function(){
      if (Date.now() > start + 60000) {
        return cb("Transaction approve timeout has expired. Try to repeat later.");
      }
      return getTransactionInfo({
        token: "vlx_native",
        network: network,
        tx: tx
      }, function(err, moreInfo){
        var ref$;
        if ((moreInfo != null ? moreInfo.status : void 8) === 'confirmed' || (moreInfo != null ? (ref$ = moreInfo.info) != null ? ref$.status : void 8 : void 8) === "0x1") {
          return cb(null, moreInfo);
        }
      });
    };
  };
  checkTx = function(arg$, cb){
    var start, network, tx, timerCb;
    start = arg$.start, network = arg$.network, tx = arg$.tx;
    timerCb = function(err, res){
      clearInterval(checkTx.timer);
      return cb(err, res);
    };
    return checkTx.timer = setInterval(checkTxConfirmation({
      start: start,
      network: network,
      tx: tx
    }, timerCb), 1000);
  };
  creationAccountSubscribe = function(arg$, cb){
    var store, web3t, signature, timeout, acc_type, activationEpoch, deactivationEpoch, voter, inProcess, commitment, callback, err;
    store = arg$.store, web3t = arg$.web3t, signature = arg$.signature, timeout = arg$.timeout, acc_type = arg$.acc_type, activationEpoch = arg$.activationEpoch, deactivationEpoch = arg$.deactivationEpoch, voter = arg$.voter, inProcess = arg$.inProcess;
    if (signature == null) {
      return cb("[Creation-account-subscribe] error: Signature is required");
    }
    commitment = 'confirmed';
    if (store.staking.webSocketAvailable === false) {
      return cb(null);
    }
    callback = function(data){
      var wallet;
      if (data.err != null) {
        store.staking.creatingStakingAccount = false;
        return cb("An error occurred during stake account creation.");
      }
      store.staking.getAccountsFromCashe = true;
      wallet = find(function(it){
        return it.coin.token === 'vlx_native';
      })(
      store.current.account.wallets);
      if (wallet == null) {
        store.staking.creatingStakingAccount = false;
        return cb("Velas Native wallet not found!");
      }
      return checkTx({
        network: wallet.network,
        tx: signature,
        start: Date.now()
      }, function(err, info){
        var onProgress;
        if ((info != null ? info.status : void 8) === "pending") {
          store.staking.creatingStakingAccount = false;
          return cb("Split transaction still in process. It may take several minutes");
        }
        if (err != null) {
          store.staking.creatingStakingAccount = false;
          return cb("An error occurred during stake account creation: " + err);
        }
        onProgress = function(){};
        return addStakeAccount(store, web3t, info, {
          acc_type: acc_type,
          activationEpoch: activationEpoch,
          deactivationEpoch: deactivationEpoch,
          voter: voter,
          inProcess: inProcess
        }, onProgress, function(err){
          var infoData, ref$, ref1$, ref2$, ref3$, ref4$, ref5$, pubkey, onProgress;
          if (err != null) {
            store.staking.creatingStakingAccount = false;
            return cb(err);
          }
          store.staking.creatingStakingAccount = false;
          infoData = info != null ? (ref$ = info.data) != null ? (ref1$ = ref$.transaction) != null ? (ref2$ = ref1$.message) != null ? (ref3$ = ref2$.instructions) != null ? (ref4$ = ref3$[0]) != null ? (ref5$ = ref4$.parsed) != null ? ref5$.info : void 8 : void 8 : void 8 : void 8 : void 8 : void 8 : void 8;
          if (infoData == null) {
            return cb(null);
          }
          pubkey = infoData != null ? infoData.newAccount : void 8;
          searchNewAccount(store, pubkey);
          if (acc_type !== 'split') {
            return cb(null);
          }
          onProgress = function(it){
            return store.staking.pools = convertPoolsToViewModel(arrayFrom$(it));
          };
          return queryPools({
            store: store,
            web3t: web3t,
            onProgress: onProgress
          }, function(err, pools){
            filterPools(pools);
            return cb(null);
          });
        });
      });
    };
    try {
      return web3t.velas.NativeStaking.connection.onSignature(signature, callback, commitment);
    } catch (e$) {
      err = e$;
      store.staking.creatingStakingAccount = false;
      console.log("Account creation error: ", err);
      return cb("An error occurred during stake account creation.");
    }
  };
  searchNewAccount = function(store, pubkey){
    var index, perPage;
    index = findIndex(function(it){
      return it.pubkey === pubkey;
    })(
    sortBy(function(it){
      return it.seedIndex;
    })(
    store.staking.accounts));
    if (index < 0) {
      return;
    }
    if (store.staking.accounts[index] == null) {
      return;
    }
    perPage = store.staking.accounts_per_page;
    store.staking.current_accounts_page = Math.ceil(div(index + 1, perPage));
    return highlight(store, index);
  };
  module.exports = {
    creationAccountSubscribe: creationAccountSubscribe,
    addStakeAccount: addStakeAccount,
    filterPools: filterPools,
    subscribeToStakeAccount: subscribeToStakeAccount,
    queryPools: queryPools,
    queryAccounts: queryAccounts,
    convertAccountsToViewModel: convertAccountsToViewModel,
    convertPoolsToViewModel: convertPoolsToViewModel
  };
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
}).call(this);
