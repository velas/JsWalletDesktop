// Generated by LiveScript 1.6.0
(function(){
  var navigate, seedmem, bip39, alert, ref$, words, map, filter, join, getLang, clean, fix, notInDictionary;
  navigate = require('./navigate.ls');
  seedmem = require('./seed.ls');
  bip39 = require('../web3t/providers/deps.js').bip39;
  alert = require('./pages/confirmation.ls').alert;
  ref$ = require('prelude-ls'), words = ref$.words, map = ref$.map, filter = ref$.filter, join = ref$.join;
  getLang = require('./get-lang.ls');
  clean = function(it){
    var ref$;
    return (ref$ = it.match(/[a-z]+/)) != null ? ref$[0] : void 8;
  };
  fix = compose$(words, map(clean), filter(function(it){
    return it != null;
  }), join(" "));
  notInDictionary = function(word){
    return !in$(word, bip39.wordlists.EN);
  };
  module.exports = function(store, web3t){
    var lang, generateSeed, next, verifySeed, save;
    if (store == null || web3t == null) {
      return null;
    }
    lang = getLang(store);
    generateSeed = function(){
      /* Uncomment below for supporting valid 256-bits 24-seed-words mnemonic (must be fixed on all wallets types at the same time) */
      var seed;
      seed = bip39.generateMnemonic(256);
      store.current.seedWords = seed.split(' ').map(function(it){
        return {
          part: it
        };
      });
      return store.current.seedGenerated = true;
    };
    next = function(){
      return navigate(store, web3t, ':init');
    };
    verifySeed = function(cb){
      var empty, e, i$, to$, i;
      empty = filter(function(it){
        return it.part.trim().length === 0;
      })(
      store.current.seedWords);
      if (empty.length !== 0) {
        store.current.alert = "Please fill all words";
        return cb("cancelled");
      }
      /* First check mnemonic generated with 256 bits length seed */
      try {
        bip39.mnemonicToEntropy(store.current.seedWords.map(function(it){
          return it.part;
        }).join(" "));
        return cb(null);
      } catch (e$) {
        e = e$;
      }
      /* If check fails continue to verify mnemonic generated with two 128 bits length seed phrases */
      try {
        for (i$ = 0, to$ = store.current.seedWords.length - 11; i$ <= to$; i$ += 12) {
          i = i$;
          bip39.mnemonicToEntropy(store.current.seedWords.slice(i, i + 12).map(fn$).join(" "));
        }
        return cb(null);
      } catch (e$) {
        e = e$;
        alert(store, "Seed phrase checksum not match. Please try again.");
        return store.current.page = 'newseedrestore';
      }
      function fn$(it){
        return it.part;
      }
    };
    save = function(){
      return verifySeed(function(err){
        if (err != null) {
          return;
        }
        seedmem.mnemonic = store.current.seedWords.map(function(it){
          return it.part;
        }).join(' ');
        store.current.savedSeed = true;
        seedmem.set(seedmem.mnemonic);
        return next();
      });
    };
    return {
      save: save,
      generateSeed: generateSeed,
      next: next
    };
  };
  function compose$() {
    var functions = arguments;
    return function() {
      var i, result;
      result = functions[0].apply(this, arguments);
      for (i = 1; i < functions.length; ++i) {
        result = functions[i](result);
      }
      return result;
    };
  }
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
