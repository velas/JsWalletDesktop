// Generated by LiveScript 1.6.0
(function(){
  var ref$, filter, find, cut, money, seed, useNetwork, check, navigate, getPrimaryInfo, copyToClipboard, confirm, prompt, alert, notify, promptPassword, promptChooseToken, getLang, bip39, generateWallet, state, adjustColor, buildSchema, out$ = typeof exports != 'undefined' && exports || this, toString$ = {}.toString;
  ref$ = require('prelude-ls'), filter = ref$.filter, find = ref$.find;
  ref$ = require('./tools.ls'), cut = ref$.cut, money = ref$.money;
  seed = require('./seed.ls');
  useNetwork = require('./use-network.ls');
  check = require('./pin.ls').check;
  navigate = require('./navigate.ls');
  getPrimaryInfo = require('./get-primary-info.ls');
  copyToClipboard = require('copy-to-clipboard');
  ref$ = require('./pages/confirmation.ls'), confirm = ref$.confirm, prompt = ref$.prompt, alert = ref$.alert, notify = ref$.notify, promptPassword = ref$.promptPassword, promptChooseToken = ref$.promptChooseToken;
  getLang = require('./get-lang.ls');
  bip39 = require('../web3t/providers/deps.js').bip39;
  out$.generateWallet = generateWallet = function(){
    return bip39.generateMnemonic();
  };
  state = {
    timeout: null
  };
  adjustColor = function(col, amt){
    var usePound, num, r, b, g;
    usePound = false;
    if (col[0] === '#') {
      col = col.slice(1);
      usePound = true;
    }
    num = parseInt(col, 16);
    r = (num >> 16) + amt;
    if (r > 255) {
      r = 255;
    } else if (r < 0) {
      r = 0;
    }
    b = (num >> 8 & 255) + amt;
    if (b > 255) {
      b = 255;
    } else if (b < 0) {
      b = 0;
    }
    g = (num & 255) + amt;
    if (g > 255) {
      g = 255;
    } else if (g < 0) {
      g = 0;
    }
    return (usePound ? '#' : '') + (g | b << 8 | r << 16).toString(16);
  };
  buildSchema = function(firstColor){
    var secondColor, thirdColor;
    secondColor = adjustColor(firstColor, 50);
    thirdColor = adjustColor(firstColor, 100);
    return {
      backgroundImage: "linear-gradient(90deg, " + firstColor + " 0%, " + secondColor + " 89%, " + thirdColor + " 100%)"
    };
  };
  module.exports = function(store, web3t){
    var current, lock, refresh, notInDictionary, checkProblem, balancesAreCalculated, changeSeed, saveSeed, lang, editSeed, cancelTry, checkPin, enterPin, generate, switchNetwork, activateS, activateS1, activateS2, activateS3, info, primaryColor, walletStyle, openAccount, closeAccount, openMigration, closeMigration, openLanguage, closeLanguage, accountLeft, accountRight, changeAccountIndex, exportPrivateKey;
    if (store == null || web3t == null) {
      return null;
    }
    current = store.current;
    lock = function(){
      return navigate(store, web3t, 'locked');
    };
    refresh = function(){
      console.log("menu-funcs refresh");
      store.forceReload = true;
      store.forceReloadTxs = true;
      store.transactions.all = [];
      store.transactions.applied = [];
      return web3t.refresh(function(){
        store.forceReload = false;
        return store.forceReloadTxs = false;
      });
    };
    notInDictionary = function(word){
      return !in$(word, bip39.wordlists.EN);
    };
    checkProblem = function(seed){
      var words, wrongWords;
      if (toString$.call(seed).slice(8, -1) !== 'String') {
        return "expected seed";
      }
      if (seed.toLowerCase() !== seed) {
        return "expected lowercase";
      }
      words = seed.split(' ');
      wrongWords = filter(notInDictionary)(
      words);
      if (wrongWords.length > 0) {
        return "some words are not in dictionary";
      }
      return "";
    };
    balancesAreCalculated = find(function(it){
      var ref$;
      return (ref$ = it.status) === 'error' || ref$ === 'loading';
    })(
    store.current.account.wallets) == null;
    changeSeed = function(event){
      state.timeout = clearTimeout(state.timeout);
      current.seed = event.target.value;
      seedmem.mnemonic = event.target.value;
      current.seedProblem = checkProblem(event.target.value);
      return state.timeout = setTimeout(refresh, 2000);
    };
    saveSeed = function(){
      seed.set(seedmem.mnemonic);
      return current.savedSeed = true;
    };
    lang = getLang(store);
    editSeed = function(){
      return confirm(store, lang.secretPhraseChange, function(agree){
        if (agree == null) {
          return;
        }
        store.current.pin = "";
        return current.tryEditSeed = true;
      });
    };
    cancelTry = function(){
      return current.tryEditSeed = false;
    };
    checkPin = function(){
      if (!check(store.current.pin)) {
        return;
      }
      cancelTry();
      return current.savedSeed = false;
    };
    enterPin = function(e){
      return store.current.pin = e.target.value;
    };
    generate = function(){
      return confirm(store, "Are you sure you want to override the current seed?", function(agree){
        if (agree == null) {
          return;
        }
        current.seed = generateWallet();
        seedmem.mnemonic = generateWallet();
        return createAccount();
      });
    };
    switchNetwork = function(){
      var network;
      store.forceReload = true;
      store.forceReloadTxs = true;
      store.transactions.all = [];
      store.transactions.applied = [];
      network = (function(){
        switch (false) {
        case store.current.network !== 'mainnet':
          return 'testnet';
        default:
          return 'mainnet';
        }
      }());
      return useNetwork(web3t, store, network, function(){});
    };
    activateS = curry$(function(name, event){
      return store.menu.active = name;
    });
    activateS1 = activateS('s1');
    activateS2 = activateS('s2');
    activateS3 = activateS('s3');
    info = getPrimaryInfo(store);
    primaryColor = info.color;
    walletStyle = (function(){
      switch (false) {
      case primaryColor != null:
        return {};
      default:
        return buildSchema(primaryColor);
      }
    }());
    openAccount = function(){
      var accountName;
      accountName = store.current.account.accountName;
      return store.current.manageAccount = true;
    };
    closeAccount = function(){
      return store.current.manageAccount = false;
    };
    openMigration = function(){};
    closeMigration = function(){
      return store.current.tokenMigration = null;
    };
    openLanguage = function(){
      return store.current.chooseLanguage = true;
    };
    closeLanguage = function(){
      return store.current.chooseLanguage = false;
    };
    accountLeft = function(){
      var cb;
      cb = console.log;
      if (!(store.current.accountIndex >= 1)) {
        return alert(store, "0 is smallest account index", cb);
      }
      store.current.accountIndex -= 1;
      return refresh();
    };
    accountRight = function(){
      var cb;
      cb = console.log;
      if (!(store.current.accountIndex <= 999999999)) {
        return alert(store, "999999999 is highest account index", cb);
      }
      store.current.accountIndex += 1;
      return refresh();
    };
    changeAccountIndex = function(event){
      var val;
      if (!(event != null && event.target)) {
        return;
      }
      val = event.target.value;
      if (val.match(/[0-9]+/) == null) {
        return;
      }
      val = parseInt(val);
      if (val < 0 || val > 999999999) {
        val = 0;
      }
      store.transactions.all = [];
      store.transactions.applied = [];
      store.forceReload = true;
      store.forceReloadTxs = true;
      store.current.accountIndex = val;
      changeAccountIndex.timer = clearTimeout(changeAccountIndex.timer);
      return changeAccountIndex.timer = setTimeout(refresh, 2000);
    };
    exportPrivateKey = function(){
      var cb;
      cb = console.log;
      return promptPassword(store, lang.privateKeyEnterPin, function(pin){
        var index;
        if (pin + "".trim().length === 0) {
          return;
        }
        if (!check(pin)) {
          return alert(store, "wrong pin", cb);
        }
        index = store.current.accountIndex;
        store.current.promptAnswer = "VLX";
        return promptChooseToken(store, lang.privateKeyEnterCoin, function(tokenInput){
          var token, wallets, ref$, ref1$, wallet, message;
          if (tokenInput + "".trim().length === 0) {
            return;
          }
          if (tokenInput === 'VLX') {
            tokenInput = 'VLX2';
          }
          if (tokenInput == null) {
            return alert(store, "token is empty", cb);
          }
          token = (tokenInput != null ? tokenInput : "").toLowerCase();
          wallets = (ref$ = (ref1$ = current.account) != null ? ref1$.wallets : void 8) != null
            ? ref$
            : [];
          wallet = find(function(it){
            var ref$;
            return ((ref$ = it.coin) != null ? ref$.token : void 8) === token;
          })(
          wallets);
          if (wallet == null) {
            return alert(store, "Wallet not found for " + token, cb);
          }
          message = "This is your Private KEY";
          copyToClipboard(wallet.privateKey);
          return notify(store, "Your Private KEY is copied into your clipboard", cb);
        });
      });
    };
    return {
      exportPrivateKey: exportPrivateKey,
      balancesAreCalculated: balancesAreCalculated,
      checkPin: checkPin,
      changeAccountIndex: changeAccountIndex,
      accountLeft: accountLeft,
      accountRight: accountRight,
      openAccount: openAccount,
      closeAccount: closeAccount,
      openMigration: openMigration,
      closeMigration: closeMigration,
      openLanguage: openLanguage,
      closeLanguage: closeLanguage,
      current: current,
      walletStyle: walletStyle,
      info: info,
      activateS1: activateS1,
      activateS2: activateS2,
      activateS3: activateS3,
      switchNetwork: switchNetwork,
      generate: generate,
      enterPin: enterPin,
      cancelTry: cancelTry,
      editSeed: editSeed,
      saveSeed: saveSeed,
      changeSeed: changeSeed,
      refresh: refresh,
      lock: lock
    };
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
