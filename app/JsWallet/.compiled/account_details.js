// Generated by LiveScript 1.6.0
(function(){
  var react, reactDom, navigate, getPrimaryInfo, web3, bignumber, getLang, historyFuncs, ref$, getAllActiveStake, creationAccountSubscribe, icon, map, split, filter, find, foldl, sortBy, unique, head, each, findIndex, div, times, plus, minus, velasNodeTemplate, hdkey, bip39, md5, menuFuncs, btoa, Buffer, copiedInform, round5, ethToVlx, vlxToEth, switchAccount, roundHuman, roundNumber, icons, placeholder, epoch, alert, notify, confirm, prompt2, prompt3, promptStakeAuthorize, button, addressHolder, alertTxn, amountField, seedmem, burger, getErrorMessage, RewardsStats, moment, loader, copy, isValidAddress, cb, asCallback, toKeystore, showValidator, Rewards, stakingContent, accountDetails, stringify, fetchEpochRewards, prevEpochData, queryRewardsLoop, get_first_slot_in_epoch, tryGetExtraSlot, get_confirmed_block_with_encoding, retrieveRewardData;
  react = require('react');
  reactDom = require('react-dom');
  navigate = require('../../navigate.ls');
  getPrimaryInfo = require('../../get-primary-info.ls');
  web3 = require('../../web3.ls');
  bignumber = require('bignumber.js');
  getLang = require('../../get-lang.ls');
  historyFuncs = require('../../history-funcs.ls');
  ref$ = require('../../staking-funcs.ls'), getAllActiveStake = ref$.getAllActiveStake, creationAccountSubscribe = ref$.creationAccountSubscribe;
  icon = require('../icon.ls');
  ref$ = require('prelude-ls'), map = ref$.map, split = ref$.split, filter = ref$.filter, find = ref$.find, foldl = ref$.foldl, sortBy = ref$.sortBy, unique = ref$.unique, head = ref$.head, each = ref$.each, findIndex = ref$.findIndex;
  ref$ = require('../../math.ls'), div = ref$.div, times = ref$.times, plus = ref$.plus, minus = ref$.minus;
  velasNodeTemplate = require('../../velas/velas-node-template.ls');
  ref$ = require('../../../web3t/providers/deps.js'), hdkey = ref$.hdkey, bip39 = ref$.bip39;
  md5 = require('md5');
  menuFuncs = require('../../menu-funcs.ls');
  btoa = require('btoa');
  Buffer = require('safe-buffer').Buffer;
  copiedInform = require('../../copied-inform.ls');
  round5 = require('../../round5.ls');
  ref$ = require('../../../web3t/addresses.js'), ethToVlx = ref$.ethToVlx, vlxToEth = ref$.vlxToEth;
  switchAccount = require('../switch-account.ls');
  roundHuman = require('../../round-human.ls');
  roundNumber = require('../../round-number.ls');
  icons = require('../../icons.ls');
  placeholder = require('../placeholder.ls');
  epoch = require('../epoch.ls');
  ref$ = require('../confirmation.ls'), alert = ref$.alert, notify = ref$.notify, confirm = ref$.confirm, prompt2 = ref$.prompt2, prompt3 = ref$.prompt3, promptStakeAuthorize = ref$.promptStakeAuthorize;
  button = require('../../components/button.ls');
  addressHolder = require('../../components/address-holder.ls');
  alertTxn = require('../alert-txn.ls');
  amountField = require('../../components/amount-field.ls');
  seedmem = require('../../seed.ls');
  burger = require('../../components/burger.ls');
  getErrorMessage = require('./error-funcs.ls').getErrorMessage;
  RewardsStats = require('./rewards-stats.ls');
  moment = require('moment');
  loader = require('../../components/popups/loader.ls');
  copy = require('../../components/copy.ls');
  isValidAddress = require('../../api.ls').isValidAddress;
  cb = console.log;
  asCallback = function(p, cb){
    p['catch'](function(err){
      return cb(err);
    });
    return p.then(function(data){
      return cb(null, data);
    });
  };
  toKeystore = function(store, withKeystore){
    var mnemonic, seed, wallet, index, password, staking, mining;
    mnemonic = seedmem.mnemonic;
    seed = bip39.mnemonicToSeed(mnemonic);
    wallet = hdkey.fromMasterSeed(seed);
    index = store.current.accountIndex;
    password = md5(wallet.derivePath("m1").deriveChild(index).getWallet().getAddress().toString('hex'));
    staking = (function(){
      switch (false) {
      case store.urlParams.anotheracc == null:
        return {
          address: window.toEthAddress(store.urlParams.anotheracc)
        };
      default:
        return getPair(wallet, 'm0', index, password, false);
      }
    }());
    mining = getPair(wallet, 'm0/2', index, password, withKeystore);
    return {
      staking: staking,
      mining: mining,
      password: password
    };
  };
  showValidator = function(store, web3t){
    return function(validator){
      return react.createElement('li', {}, ' ' + validator);
    };
  };
  Rewards = function(props){
    var lang, style, account, activationEpoch, ref$, rewards, setRewards, isLoading, setLoading, buildRewards, stakerPoolStyle, stats, mountedRef, returnFn, fetchRewards, children;
    lang = getLang(store);
    style = getPrimaryInfo(store);
    account = store.staking.chosenAccount;
    activationEpoch = account.activationEpoch;
    ref$ = react.useState([]), rewards = ref$[0], setRewards = ref$[1];
    ref$ = react.useState(true), isLoading = ref$[0], setLoading = ref$[1];
    buildRewards = function(item){
      var epoch, rewardSlot, amount, newBalance, percentChange, apr, $amount, $newBalance, $class, $trClass, children;
      epoch = item.epoch, rewardSlot = item.rewardSlot, amount = item.amount, newBalance = item.newBalance, percentChange = item.percentChange, apr = item.apr;
      if (epoch === store.staking.currentEpoch) {
        return null;
      }
      $amount = roundHuman(div(amount, Math.pow(10, 9)), {
        decimals: 9
      });
      $newBalance = roundHuman(div(newBalance, Math.pow(10, 9)), {
        decimals: 9
      });
      if (store.staking.currentEpoch === epoch) {
        rewardSlot = $amount = $newBalance = percentChange = apr = "Loading...";
      }
      $class = epoch === store.staking.currentEpoch ? "syncing" : "";
      $trClass = epoch === store.staking.currentEpoch ? "current-epoch " : "";
      return react.createElement('tr', {
        key: "epoch" + epoch,
        className: $trClass + " " + epoch
      }, children = [
        react.createElement('td', {
          key: "epoch" + epoch + "1",
          className: $class + ""
        }, ' ' + epoch), react.createElement('td', {
          key: "epoch" + epoch + "2",
          className: $class + ""
        }, ' ' + rewardSlot), react.createElement('td', {
          key: "epoch" + epoch + "3",
          className: $class + ""
        }, ' ' + $amount), react.createElement('td', {
          key: "epoch" + epoch + "4",
          className: $class + ""
        }, ' ' + $newBalance), react.createElement('td', {
          key: "epoch" + epoch + "5",
          className: $class + ""
        }, ' ' + percentChange), react.createElement('td', {
          key: "epoch" + epoch + "6",
          className: $class + ""
        }, ' ' + apr)
      ]);
    };
    stakerPoolStyle = {
      maxWidth: 200,
      background: style.app.stats
    };
    stats = {
      background: style.app.stats
    };
    mountedRef = react.useRef(true);
    returnFn = function(){
      return mountedRef.current = false;
    };
    fetchRewards = react.useCallback(async function(){
      fetchEpochRewards(account.address, activationEpoch, function(err, $rewards){
        if (!mountedRef.current) {
          return null;
        }
        setLoading(false);
        setRewards($rewards);
        store.staking.chosenAccount.rewards = $rewards;
      });
    }, [mountedRef]);
    react.useEffect(function(){
      fetchRewards();
      return returnFn;
    }, [fetchRewards]);
    return react.createElement('div', {
      className: 'section rewards'
    }, children = [
      react.createElement('div', {
        className: 'title'
      }, children = react.createElement('h2', {}, ' ' + lang.uRewards)), react.createElement('div', {
        className: 'table-scroll'
      }, children = isLoading
        ? react.createElement('span', {
          className: 'entities-loader'
        }, children = react.createElement('span', {
          className: 'inner-section'
        }, children = react.createElement('h3', {
          className: 'item blink'
        }, ' Loading... ')))
        : react.createElement('table', {}, children = [
          react.createElement('thead', {}, children = react.createElement('tr', {}, children = [
            react.createElement('td', {
              width: "3%",
              style: stakerPoolStyle,
              title: "Epoch"
            }, ' ' + lang.epoch + ' (?)'), react.createElement('td', {
              width: "25%",
              style: stats,
              title: "Reward Slot"
            }, ' Reward Slot (?)'), react.createElement('td', {
              width: "25%",
              style: stats,
              title: "Amount"
            }, ' ' + lang.amount + ' (?)'), react.createElement('td', {
              width: "25%",
              style: stats,
              title: "New Balance"
            }, ' ' + lang.newBalance + ' (?)'), react.createElement('td', {
              width: "7%",
              style: stats,
              title: "Percent Change"
            }, ' Percent Change (?)'), react.createElement('td', {
              width: "7%",
              style: stats,
              title: "APR"
            }, ' APR (?)')
          ])), react.createElement('tbody', {}, children = map(buildRewards)(
          rewards))
        ])), react.createElement(RewardsStats, {
        rewards: rewards
      })
    ]);
  };
  stakingContent = function(store, web3t){
    var goBack, style, lang, down, account, address, activationEpoch, deactivationEpoch, rentExemptReserve, checked, stake, stakeInitial, commission, lastVote, lockup, staker, withdrawer, isValidator, status, myStake, credits_observed, validator, pubkey, lamports, up;
    goBack = historyFuncs(store, web3t).goBack;
    style = getPrimaryInfo(store);
    lang = getLang(store);
    down = function(it){
      return it.toLowerCase();
    };
    if (!store.staking.chosenAccount) {
      return null;
    }
    account = store.staking.chosenAccount;
    address = account.address, activationEpoch = account.activationEpoch, deactivationEpoch = account.deactivationEpoch, rentExemptReserve = account.rentExemptReserve, checked = account.checked, stake = account.stake, stakeInitial = account.stakeInitial, commission = account.commission, lastVote = account.lastVote, lockup = account.lockup, staker = account.staker, withdrawer = account.withdrawer, isValidator = account.isValidator, status = account.status, myStake = account.myStake, credits_observed = account.credits_observed, validator = account.validator, pubkey = account.pubkey, lamports = account.lamports;
    up = function(str){
      return (str || '').trim().toUpperCase();
    };
    return web3t.vlx_native.getAddress(function(err, accountAddress){
      var canWithdraw, canDelegate, exitFromStakeAccount, rent, balanceRaw, buttonPrimary3Style, seedStyle, filterIcon, commingSoon, pairs, iStakeChoosenPool, wallet, velasNodeAppliedTemplate, velasNodeAppliedTemplateLine, ref$, accountLeft, accountRight, changeAccountIndex, updateCurrent, accountLeftProxy, accountRightProxy, changeAccountIndexProxy, lineStyle, activate, activateLine, activateString, activateSsh, activateDo, activeClass, activeLine, activeString, activeSsh, activeDo, getBalance, getOptions, useMin, useMax, yourBalance, isSpinned, cancelPool, refresh, removeStakeAcc, withdraw, delegate, undelegate, setAuthorizeStaker, splitAccount, iconStyle, stakerPoolStyle, stats, hasValidator, active_stake, inactive_stake, delegated_stake, usdRate, usdBalance, usdRent, usdActive_stake, usdInactive_stake, usdDelegated_stake, $validator, activeBalanceIsZero, maxEpoch, myStakeMaxPart, myStakeMaxPartVLX, $status, inactiveStakeLabel, lockupUnixTimestamp, epoch, lockup, isLocked, dateExpires, timeExpires, lockupWarningStyle, addressContainerStyle, children, moreStyle, tipStyle, linkStyle, notificationStyle;
      canWithdraw = deepEq$(up(withdrawer), up(accountAddress), '===');
      canDelegate = deepEq$(up(staker), up(accountAddress), '===');
      exitFromStakeAccount = !canWithdraw && !canDelegate;
      rent = div(rentExemptReserve, Math.pow(10, 9));
      balanceRaw = !isNaN(rent) && rent != null ? minus(lamports, rent) : lamports;
      buttonPrimary3Style = {
        border: "1px solid " + style.app.primary3,
        color: style.app.text2,
        background: style.app.primary3,
        backgroundColor: style.app.primary3Spare
      };
      seedStyle = {
        background: style.app.primary2,
        backgroundColor: style.app.primary2Spare,
        padding: 5
      };
      filterIcon = {
        filter: style.app.filterIcon
      };
      commingSoon = {
        opacity: ".3"
      };
      pairs = store.staking.keystore;
      iStakeChoosenPool = function(){
        var myStake;
        myStake = +myStake;
        return myStake >= 10000;
      };
      wallet = find(function(it){
        return it.coin.token === 'vlx_native';
      })(
      store.current.account.wallets);
      velasNodeAppliedTemplate = split("\n")(
      velasNodeTemplate(
      pairs));
      velasNodeAppliedTemplateLine = function(it){
        return "echo '" + it + "' | base64 --decode | sh";
      }(
      btoa(
      velasNodeTemplate(
      pairs)));
      if (pairs.mining == null) {
        return null;
      }
      ref$ = menuFuncs(store, web3t), accountLeft = ref$.accountLeft, accountRight = ref$.accountRight, changeAccountIndex = ref$.changeAccountIndex;
      updateCurrent = function(func){
        return function(data){
          func(data);
          return staking.init({
            store: store,
            web3t: web3t
          }, function(){
            return store.staking.keystore = toKeystore(store, false);
          });
        };
      };
      accountLeftProxy = updateCurrent(accountLeft);
      accountRightProxy = updateCurrent(accountRight);
      changeAccountIndexProxy = updateCurrent(changeAccountIndex);
      lineStyle = {
        padding: "10px",
        width: '100%'
      };
      activate = function(tab){
        return function(){
          return store.staking.tab = tab;
        };
      };
      activateLine = activate('line');
      activateString = activate('string');
      activateSsh = activate('ssh');
      activateDo = activate('do');
      activeClass = function(tab){
        if (store.staking.tab === tab) {
          return 'active';
        } else {
          return '';
        }
      };
      activeLine = activeClass('line');
      activeString = activeClass('string');
      activeSsh = activeClass('ssh');
      activeDo = activeClass('do');
      getBalance = function(){
        var wallet;
        wallet = find(function(it){
          return it.coin.token === 'vlx2';
        })(
        store.current.account.wallets);
        return wallet.balance;
      };
      getOptions = function(cb){
        var iAmStaker;
        iAmStaker = iStakeChoosenPool();
        if (iAmStaker) {
          return cb(null);
        }
        return web3t.velas.Staking.candidateMinStake(function(err, data){
          var min, balance, stake, max;
          if (err != null) {
            return cb(err);
          }
          min = (function(){
            switch (false) {
            case !(+store.staking.stakeAmountTotal >= 10000):
              return 1;
            default:
              return div(data, Math.pow(10, 18));
            }
          }());
          balance = minus(getBalance(), 0.1);
          stake = store.staking.add.addValidatorStake;
          if (10000 > +stake) {
            return cb(lang.amountLessStaking);
          }
          if (+balance < +stake) {
            return cb(lang.balanceLessStaking);
          }
          max = +balance;
          return cb(null, {
            min: min,
            max: max
          });
        });
      };
      useMin = function(){
        return store.staking.add.addValidatorStake = 10000;
      };
      useMax = function(){
        return store.staking.add.addValidatorStake = Math.max(minus(getBalance(), 0.1), 0);
      };
      yourBalance = div(balanceRaw, Math.pow(10, 9));
      isSpinned = (store.staking.allPoolsLoaded === false || store.staking.allPoolsLoaded == null) && store.staking.poolsAreLoading === true ? "spin disabled" : "";
      cancelPool = function(){
        return store.staking.chosenAccount = null;
      };
      refresh = function(){
        var cb;
        store.staking.allPoolsLoaded = false;
        store.staking.getAccountsFromCashe = false;
        if ((store.staking.allPoolsLoaded === false || store.staking.allPoolsLoaded == null) && store.staking.poolsAreLoading === true) {
          return false;
        }
        store.staking.poolsAreLoading = true;
        cb = console.log;
        return staking.init({
          store: store,
          web3t: web3t
        }, function(err){
          if (err != null) {
            return cb(err);
          }
          return cb(null, 'done');
        });
      };
      removeStakeAcc = function(public_key){
        var index, accountIndex, index2, ref$;
        index = findIndex(function(it){
          return it.pubkey === public_key;
        })(
        store.staking.accounts);
        if (index > -1) {
          store.staking.accounts.splice(index, 1);
        }
        accountIndex = store.current.accountIndex;
        index2 = findIndex(function(it){
          return it.pubkey === public_key;
        })(
        (ref$ = store.staking.accountsCached[accountIndex]) != null
          ? ref$
          : []);
        if (index2 > -1) {
          return ((ref$ = store.staking.accountsCached[accountIndex]) != null
            ? ref$
            : []).splice(index2, 1);
        }
      };
      withdraw = function(){
        return confirm(store, lang.areYouSureToWithdraw, function(agree){
          var amount;
          if (agree === false) {
            return;
          }
          amount = plus(account.lamports, account.rent);
          return asCallback(web3t.velas.NativeStaking.withdraw(address, amount), function(err, result){
            var errMessage;
            errMessage = getErrorMessage(err, result);
            if (errMessage != null) {
              return alert(store, errMessage);
            }
            return notify(store, lang.fundsWithdrawn, function(){
              store.staking.getAccountsFromCashe = true;
              removeStakeAcc(account.pubkey);
              if (store.staking.webSocketAvailable === false) {
                return navigate(store, web3t, 'validators');
              }
              return store.current.page = 'validators';
            });
          });
        });
      };
      delegate = function(){
        return navigate(store, web3t, 'poolchoosing');
      };
      undelegate = function(){
        return confirm(store, lang.areYouSureToUndelegate, function(agree){
          if (agree === false) {
            return;
          }
          return asCallback(web3t.velas.NativeStaking.undelegate(store.staking.chosenAccount.address), function(err, result){
            var errMessage;
            if (err != null) {
              console.error("Undelegate error: ", err);
            }
            errMessage = getErrorMessage(err, result);
            if (errMessage != null) {
              return alert(store, errMessage);
            }
            return setTimeout(function(){
              return notify(store, lang.fundsUndelegated, function(){
                if (store.staking.webSocketAvailable === false) {
                  return navigate(store, web3t, 'validators');
                }
                return store.current.page = 'validators';
              });
            }, 1000);
          });
        });
      };
      setAuthorizeStaker = function(){
        return promptStakeAuthorize(store, 'Update the account with a new authorized staker', function(newAuthorizedPubkey){
          var ref$, custodian, pubKey, withdrawer, wallet, params;
          if (!newAuthorizedPubkey) {
            return;
          }
          store.staking.settingNewStakingAuthority = true;
          ref$ = store.staking.chosenAccount, custodian = ref$.custodian, pubKey = ref$.pubKey, withdrawer = ref$.withdrawer;
          wallet = store.current.account.wallets.find(function(it){
            return it.coin.token === 'vlx_native';
          });
          if (wallet == null) {
            return alert(store, 'VLX Native wallet was not found');
          }
          params = {
            stakePubkey: pubKey,
            authorizedPubkey: wallet.publicKey,
            newAuthorizedPubkey: newAuthorizedPubkey,
            custodianPubkey: custodian
          };
          console.log({
            params: params
          });
          return asCallback(web3t.velas.NativeStaking.authorize(params), function(err, result){
            var errMessage;
            store.staking.settingNewStakingAuthority = false;
            errMessage = getErrorMessage(err, result);
            if (errMessage != null) {
              store.staking.settingNewStakingAuthority = false;
              return alert(store, errMessage);
            }
            return notify(store, lang.newStakeAuthorityWasSuccessfullySetTo + " " + newAuthorizedPubkey, function(){
              var canWithdraw1, canDelegate1, exitFromStakeAccount1;
              store.staking.chosenAccount.staker = newAuthorizedPubkey;
              store.staking.settingNewStakingAuthority = false;
              canWithdraw1 = deepEq$(up(withdrawer), up(accountAddress), '===');
              canDelegate1 = deepEq$(up(newAuthorizedPubkey), up(accountAddress), '===');
              exitFromStakeAccount1 = !canWithdraw1 && !canDelegate1;
              if (exitFromStakeAccount1) {
                store.staking.getAccountsFromCashe = false;
                store.current.page = "validators";
                store.staking.chosenAccount = null;
                return removeStakeAcc(account.pubkey);
              }
            });
          });
        });
      };
      splitAccount = function(){
        var cb, buffer;
        cb = console.log;
        buffer = {};
        return prompt3(store, lang.howMuchToSplit, function(amount){
          var min_stake, balance, thresholdAmount;
          buffer.amount = amount;
          if (amount + "".trim().length === 0) {
            store.staking.splittingStakingAccount = false;
            return;
          }
          min_stake = web3t.velas.NativeStaking.min_stake;
          balance = div(balanceRaw, Math.pow(10, 9));
          if (+buffer.amount > +balance) {
            store.staking.splittingStakingAccount = false;
            return alert(store, lang.balanceIsNotEnoughToSpend + (" " + buffer.amount + " VLX"));
          }
          if (+min_stake > +balance) {
            thresholdAmount = plus(min_stake, 0.00228288);
            store.staking.splittingStakingAccount = false;
            return alert(store, lang.balanceIsNotEnoughToCreateStakingAccount + (" (" + thresholdAmount + " VLX)"));
          }
          if (+min_stake > +buffer.amount) {
            store.staking.splittingStakingAccount = false;
            return alert(store, lang.minimalStakeMustBe + (" " + min_stake + " VLX"));
          }
          return asCallback(web3t.velas.NativeStaking.getStakingAccounts(store.staking.parsedProgramAccounts), function(err){
            if (err != null) {
              return cb(err);
            }
            store.staking.splittingStakingAccount = true;
            /* Get next account seed */
            return asCallback(web3t.velas.NativeStaking.getNextSeed(), function(err, seed){
              var errMessage, amount, fromPubkey$;
              errMessage = getErrorMessage(err, seed);
              if (errMessage != null) {
                store.staking.splittingStakingAccount = false;
                return alert(store, errMessage);
              }
              amount = buffer.amount * Math.pow(10, 9);
              /* Create new account */
              fromPubkey$ = store.staking.chosenAccount.address;
              return asCallback(web3t.velas.NativeStaking.createNewStakeAccountWithSeed(), function(err, splitStakePubkey){
                var splitStakePubkeyBase58, error, stakeAccount, $voter;
                if (err != null) {
                  store.staking.splittingStakingAccount = false;
                  return alert(store, err.toString());
                }
                try {
                  splitStakePubkeyBase58 = splitStakePubkey.toBase58();
                } catch (e$) {
                  error = e$;
                  store.staking.splittingStakingAccount = false;
                  return alert(store, error.toString());
                }
                /* Split account */
                stakeAccount = store.staking.chosenAccount.address;
                $voter = store.staking.chosenAccount.voter;
                return asCallback(web3t.velas.NativeStaking.splitStakeAccount(stakeAccount, splitStakePubkey, amount), function(err, signature){
                  var errMessage, ref$, activationEpoch, deactivationEpoch;
                  errMessage = getErrorMessage(err, signature);
                  if (errMessage != null) {
                    store.staking.splittingStakingAccount = false;
                    return alert(store, errMessage);
                  }
                  ref$ = store.staking.chosenAccount, activationEpoch = ref$.activationEpoch, deactivationEpoch = ref$.deactivationEpoch;
                  return creationAccountSubscribe({
                    store: store,
                    web3t: web3t,
                    signature: signature,
                    timeout: 1000,
                    acc_type: "split",
                    deactivationEpoch: deactivationEpoch,
                    activationEpoch: activationEpoch,
                    voter: $voter
                  }, function(err){
                    var fromPubkey$;
                    if (err != null) {
                      store.staking.splittingStakingAccount = false;
                      return alert(store, err, cb);
                    }
                    /* Update balance of stake account from which split was called */
                    fromPubkey$ = store.staking.chosenAccount.address;
                    return asCallback(web3t.velas.NativeStaking.getAccountInfo(fromPubkey$), function(err, accountInfo){
                      var split_lamports, ref$, foundAccount;
                      if (err != null) {
                        console.log("Split was confirmed");
                        store.staking.splittingStakingAccount = false;
                        return alert(store, "Split was confirmed. Please reload stake accounts manually to see updates.", cb);
                      }
                      split_lamports = accountInfo != null ? (ref$ = accountInfo.value) != null ? ref$.lamports : void 8 : void 8;
                      /* Find account in store.staking.accounts and update balance */
                      foundAccount = find(function(it){
                        return down(it.pubkey) === down(fromPubkey$);
                      })(
                      store.staking.accounts);
                      if (foundAccount != null) {
                        foundAccount.balance = div(split_lamports, Math.pow(10, 9));
                        foundAccount.balanceRaw = split_lamports + "";
                        foundAccount.lamports = split_lamports + "";
                      }
                      return notify(store, lang.accountCreatedAndFundsSplitted + ".\n\nNew stake account address: " + splitStakePubkeyBase58, function(){
                        store.staking.getAccountsFromCashe = false;
                        store.current.page = "validators";
                        return store.staking.splittingStakingAccount = false;
                      });
                    });
                  });
                });
              });
            });
          });
        });
      };
      iconStyle = {
        color: style.app.loader,
        marginTop: "10px",
        width: "inherit"
      };
      stakerPoolStyle = {
        maxWidth: 200,
        background: style.app.stats
      };
      stats = {
        background: style.app.stats
      };
      hasValidator = validator != null && validator.toString().trim() !== "";
      active_stake = div(store.staking.chosenAccount.active_stake, Math.pow(10, 9));
      inactive_stake = div(store.staking.chosenAccount.inactive_stake, Math.pow(10, 9));
      delegated_stake = plus(active_stake, inactive_stake);
      usdRate = (ref$ = wallet != null ? wallet.usdRate : void 8) != null ? ref$ : 0;
      usdBalance = roundNumber(times(yourBalance, usdRate), {
        decimals: 2
      });
      usdRent = roundNumber(times(rent, usdRate), {
        decimals: 2
      });
      usdActive_stake = roundNumber(times(active_stake, usdRate), {
        decimals: 2
      });
      usdInactive_stake = roundNumber(times(inactive_stake, usdRate), {
        decimals: 2
      });
      usdDelegated_stake = roundNumber(times(delegated_stake, usdRate), {
        decimals: 2
      });
      $validator = hasValidator ? validator : "---";
      activeBalanceIsZero = +store.staking.chosenAccount.active_stake === 0;
      maxEpoch = web3t.velas.NativeStaking.max_epoch;
      myStakeMaxPart = (function(){
        switch (false) {
        case store.staking.myStakeMaxPart == null:
          myStakeMaxPartVLX = div(parseFloat(store.staking.myStakeMaxPart), Math.pow(10, 9));
          return myStakeMaxPartVLX + " VLX";
        default:
          return "";
        }
      }());
      $status = (function(){
        switch (false) {
        case !(store.staking.chosenAccount.status === "inactive" && !hasValidator):
          return "Not Delegated";
        case !(store.staking.chosenAccount.status === "inactive" && hasValidator):
          return "Delegated (Inactive)";
        default:
          return store.staking.chosenAccount.status;
        }
      }());
      inactiveStakeLabel = (function(){
        switch (false) {
        case store.staking.chosenAccount.status !== "activating":
          return lang.warminUp;
        default:
          return lang.inactiveStake;
        }
      }());
      ref$ = store.staking.chosenAccount, lockupUnixTimestamp = ref$.lockupUnixTimestamp, epoch = ref$.epoch, lockup = ref$.lockup;
      isLocked = lockupUnixTimestamp != null && lockupUnixTimestamp > moment().unix();
      dateExpires = (function(){
        switch (false) {
        case isLocked !== true:
          return moment.unix(lockupUnixTimestamp).format("MMMM D, YYYY");
        default:
          return "";
        }
      }());
      timeExpires = (function(){
        switch (false) {
        case isLocked !== true:
          return moment.unix(lockupUnixTimestamp).format("hh:mm:ss");
        default:
          return "";
        }
      }());
      lockupWarningStyle = {
        padding: "20px",
        background: "rgb(207, 149, 44)",
        fontWeight: "bold",
        textAlign: "center",
        maxWidth: "500px"
      };
      addressContainerStyle = {
        display: "flex"
      };
      /* Render */
      return react.createElement('div', {
        className: 'staking-content delegate'
      }, children = [
        loader({
          loading: store.staking.splittingStakingAccount,
          text: "Splitting in process"
        }), loader({
          loading: store.staking.settingNewStakingAuthority,
          text: "Setting new stake authority in process"
        }), react.createElement('div', {
          id: "choosen-pull",
          className: 'single-section form-group'
        }, children = [
          react.createElement('div', {
            className: 'section'
          }, children = [
            react.createElement('div', {
              className: 'title'
            }, children = react.createElement('h2', {}, ' ' + lang.stakeAccount)), isLocked === true ? react.createElement('div', {
              className: 'description'
            }, children = react.createElement('div', {
              style: lockupWarningStyle,
              className: 'locked-warning-table'
            }, children = [react.createElement('span', {}, ' Account is locked! Lockup expires on '), " " + dateExpires, " at", " " + timeExpires])) : void 8
          ]), react.createElement('div', {
            className: 'section'
          }, children = [
            react.createElement('div', {
              className: 'title'
            }, children = react.createElement('h3', {}, ' ' + lang.address)), react.createElement('div', {
              className: 'description'
            }, children = react.createElement('div', {
              title: store.staking.chosenAccount.address + "",
              className: 'chosen-account'
            }, children = react.createElement('span', {
              style: addressContainerStyle
            }, children = [
              " " + store.staking.chosenAccount.address, react.createElement('img', {
                src: icons.imgCheck + "",
                className: 'check'
              }), copy({
                store: store,
                text: store.staking.chosenAccount.address,
                elId: "copy-address-chosenAccount"
              })
            ])))
          ]), react.createElement('div', {
            className: 'section'
          }, children = [
            react.createElement('div', {
              className: 'title'
            }, children = react.createElement('h3', {}, ' ID')), react.createElement('div', {
              className: 'description'
            }, children = react.createElement('span', {
              style: seedStyle
            }, children = " " + store.staking.chosenAccount.seed))
          ]), react.createElement('div', {
            className: 'section'
          }, children = [
            react.createElement('div', {
              className: 'title'
            }, children = react.createElement('h3', {}, ' ' + lang.rentExemptReserve)), react.createElement('div', {
              className: 'description'
            }, children = [
              react.createElement('span', {}, children = " " + rent + " VLX"), react.createElement('span', {
                className: 'usd-amount'
              }, children = " $" + usdRent)
            ])
          ]), react.createElement('div', {
            className: 'section'
          }, children = [
            react.createElement('div', {
              className: 'title'
            }, children = react.createElement('h3', {}, ' ' + lang.balance)), react.createElement('div', {
              className: 'description'
            }, children = [
              react.createElement('span', {}, children = " " + roundHuman(yourBalance) + " VLX"), react.createElement('span', {
                className: 'usd-amount'
              }, children = " $" + roundHuman(usdBalance))
            ])
          ]), react.createElement('div', {}), react.createElement('div', {}), react.createElement('div', {
            className: 'section'
          }, children = react.createElement('div', {
            className: 'title'
          }, children = react.createElement('h2', {}, ' ' + lang.stakeDelegation))), react.createElement('div', {
            className: 'section'
          }, children = [
            react.createElement('div', {
              className: 'title'
            }, children = react.createElement('h3', {}, ' ' + lang.status)), react.createElement('div', {
              className: 'description'
            }, children = react.createElement('div', {
              title: store.staking.chosenAccount.status + "",
              className: 'chosen-account'
            }, children = react.createElement('span', {}, children = " " + $status)))
          ]), react.createElement('div', {
            className: 'section'
          }, children = [
            react.createElement('div', {
              className: 'title'
            }, children = react.createElement('h3', {}, ' ' + lang.validator)), react.createElement('div', {
              className: 'description'
            }, children = react.createElement('span', {
              style: addressContainerStyle,
              className: 'chosen-account'
            }, children = [
              " " + $validator, hasValidator ? react.createElement('img', {
                src: icons.imgCheck + "",
                className: 'check'
              }) : void 8, hasValidator ? copy({
                store: store,
                text: validator,
                elId: "copy-address-validator"
              }) : void 8
            ]))
          ]), react.createElement('div', {
            className: 'section'
          }, children = [
            react.createElement('div', {
              className: 'title'
            }, children = react.createElement('h3', {}, ' ' + lang.creditsObserved)), react.createElement('div', {
              className: 'description'
            }, children = react.createElement('span', {}, children = " " + roundHuman(credits_observed)))
          ]), react.createElement('div', {
            className: 'section'
          }, children = [
            react.createElement('div', {
              className: 'title'
            }, children = react.createElement('h3', {}, ' ' + lang.delegatedStake)), react.createElement('div', {
              className: 'description'
            }, children = [
              react.createElement('span', {}, children = " " + roundHuman(delegated_stake) + " VLX"), react.createElement('span', {
                className: 'usd-amount'
              }, children = " $" + roundHuman(usdDelegated_stake))
            ])
          ]), react.createElement('div', {
            className: 'section'
          }, children = [
            react.createElement('div', {
              className: 'title'
            }, children = react.createElement('h3', {}, ' ' + lang.activeStake)), react.createElement('div', {
              className: 'description'
            }, children = [
              react.createElement('span', {}, children = " " + roundHuman(active_stake) + " VLX"), react.createElement('span', {
                className: 'usd-amount'
              }, children = " $" + roundHuman(usdActive_stake)), store.staking.myStakeMaxPart != null && false ? react.createElement('span', {
                className: 'myStakeMaxPart'
              }, children = [
                react.createElement('div', {
                  className: 'animation'
                }, children = [
                  react.createElement('div', {
                    className: 'anim-item'
                  }, ' -'), react.createElement('div', {
                    className: 'anim-item'
                  }, ' -'), react.createElement('div', {
                    className: 'anim-item'
                  }, ' >')
                ]), " " + myStakeMaxPart
              ]) : void 8
            ])
          ]), react.createElement('div', {
            className: 'section'
          }, children = [
            react.createElement('div', {
              className: 'title'
            }, children = react.createElement('h3', {}, ' ' + inactiveStakeLabel)), react.createElement('div', {
              className: 'description'
            }, children = [
              react.createElement('span', {}, children = " " + roundHuman(inactive_stake) + " VLX"), react.createElement('span', {
                className: 'usd-amount'
              }, children = " $" + roundHuman(usdInactive_stake)), store.staking.chosenAccount.status === "activating" ? (moreStyle = {
                textDecoration: "none",
                opacity: 0.8,
                lineHeight: 1.6,
                fontSize: "14px",
                letterSpacing: "2px",
                marginLeft: "5px"
              }, tipStyle = {
                color: "#16ffb2",
                opacity: 0.8
              }, linkStyle = {
                textDecoration: "none",
                color: "white",
                opacity: 0.8
              }, notificationStyle = {
                marginTop: "10px"
              }, react.createElement('div', {
                style: notificationStyle,
                className: 'notification'
              }, children = [
                react.createElement('span', {
                  style: tipStyle
                }, ' Only 25% of active stake can be activated per epoch.'), react.createElement('a', {
                  href: "https://support.velas.com/hc/en-150/articles/360021044820-Delegation-Warmup-and-Cooldown",
                  target: "_blank",
                  rel: "noopener noreferrer nofollow",
                  style: linkStyle
                }, children = react.createElement('span', {
                  style: moreStyle
                }, ' More...'))
              ])) : void 8
            ])
          ]), react.createElement('div', {
            className: 'section'
          }, children = react.createElement('div', {
            className: 'title'
          }, children = react.createElement('h2', {}, ' ' + lang.Authorities))), react.createElement('div', {
            className: 'section'
          }, children = [
            react.createElement('div', {
              className: 'title'
            }, children = react.createElement('h3', {}, ' ' + lang.stakeAuthorityAddress)), react.createElement('div', {
              className: 'description'
            }, children = [
              react.createElement('span', {
                style: addressContainerStyle,
                className: 'chosen-account'
              }, children = [
                " " + staker, react.createElement('img', {
                  src: icons.imgCheck + "",
                  className: 'check'
                }), copy({
                  store: store,
                  text: staker,
                  elId: "copy-staker-address"
                })
              ]), button({
                store: store,
                onClick: setAuthorizeStaker,
                type: 'secondary',
                text: 'Set manager',
                classes: "set-manager",
                noIcon: true
              })
            ])
          ]), react.createElement('div', {
            className: 'section'
          }, children = [
            react.createElement('div', {
              className: 'title'
            }, children = react.createElement('h3', {}, ' ' + lang.withdrawAuthorityAddress)), react.createElement('div', {
              className: 'description'
            }, children = react.createElement('span', {
              style: addressContainerStyle,
              className: 'chosen-account'
            }, children = [
              " " + withdrawer, react.createElement('img', {
                src: icons.imgCheck + "",
                className: 'check'
              }), copy({
                store: store,
                text: withdrawer,
                elId: "copy-withdawer-address"
              })
            ]))
          ]), react.createElement('div', {
            className: 'section'
          }, children = [
            react.createElement('div', {
              className: 'title'
            }, children = react.createElement('h2', {}, ' Actions')), react.createElement('div', {
              className: 'description'
            }, children = react.createElement('div', {
              className: 'buttons'
            }, children = [
              store.staking.chosenAccount.status === "inactive"
                ? react.createElement('div', {}, children = [
                  canDelegate ? button({
                    store: store,
                    onClick: delegate,
                    type: 'secondary',
                    text: lang.to_delegate,
                    icon: 'arrowRight'
                  }) : void 8, canWithdraw && isLocked === false ? button({
                    store: store,
                    onClick: withdraw,
                    type: 'secondary',
                    text: lang.withdraw,
                    icon: 'arrowLeft'
                  }) : void 8
                ])
                : canDelegate && store.staking.chosenAccount.status !== 'deactivating' ? button({
                  store: store,
                  onClick: undelegate,
                  type: 'secondary',
                  text: lang.to_undelegate,
                  icon: 'arrowLeft',
                  classes: "action-undelegate"
                }) : void 8, canDelegate ? button({
                store: store,
                onClick: splitAccount,
                type: 'secondary',
                text: lang.to_split,
                classes: "action-split",
                noIcon: true
              }) : void 8
            ]))
          ]), react.createElement(Rewards, {})
        ])
      ]);
    });
  };
  accountDetails = function(arg$){
    var store, web3t, lang, goBack, gotoSearch, info, style, borderStyle, borderStyle2, borderRight, headerTableStyle, lightText, iconColor, showClass, justGoBack, children;
    store = arg$.store, web3t = arg$.web3t;
    lang = getLang(store);
    goBack = historyFuncs(store, web3t).goBack;
    gotoSearch = function(){
      return navigate(store, web3t, 'search');
    };
    info = getPrimaryInfo(store);
    style = {
      background: info.app.wallet,
      color: info.app.text
    };
    borderStyle = {
      color: info.app.text,
      borderBottom: "1px solid " + info.app.border,
      background: info.app.background,
      backgroundColor: info.app.bgspare
    };
    borderStyle2 = {
      color: info.app.text,
      borderBottom: "1px solid " + info.app.border,
      background: "#4b2888"
    };
    borderRight = {
      color: info.app.text,
      borderRight: "1px solid " + info.app.border
    };
    headerTableStyle = {
      borderBottom: "1px solid " + info.app.border,
      background: info.app.walletLight
    };
    lightText = {
      color: info.app.color3
    };
    iconColor = {
      filter: info.app.iconFilter
    };
    showClass = store.current.openMenu ? 'hide' : "";
    justGoBack = function(){
      store.staking.fetchAccounts = false;
      store.staking.chosenAccount.stopLoadingRewards = true;
      store.staking.getAccountsFromCashe = true;
      return store.current.page = 'validators';
    };
    return react.createElement('div', {
      className: 'staking staking-1537896304'
    }, children = [
      react.createElement('div', {
        style: borderStyle,
        className: 'title'
      }, children = [
        react.createElement('div', {
          className: showClass + " header"
        }, ' ' + lang.delegateStake), react.createElement('div', {
          onClick: justGoBack,
          className: 'close'
        }, children = react.createElement('img', {
          src: icons.arrowLeft + "",
          style: iconColor,
          className: 'icon-svg'
        })), burger(store, web3t), epoch(store, web3t), switchAccount(store, web3t)
      ]), stakingContent(store, web3t)
    ]);
  };
  accountDetails.init = function(arg$, cb){
    var store, web3t, account, cb2, stakeAccounts;
    store = arg$.store, web3t = arg$.web3t;
    account = store.staking.chosenAccount;
    cb2 = function(err, data){
      return store.current.page = 'validators';
    };
    if (account == null) {
      return alert(store, "Account not found", cb2);
    }
    store.staking.chosenAccount.stopLoadingRewards = false;
    store.staking.chosenAccount.rewards = [];
    store.staking.rewardsIndex = 0;
    stakeAccounts = store.staking.parsedProgramAccounts;
    asCallback(web3t.velas.NativeStaking.getAccountInfo(store.staking.chosenAccount.pubkey), function(err, accountInfo){
      if (err != null) {
        return alert(store, err, cb2);
      }
      if (accountInfo.value == null) {
        return alert(store, "Account not found", cb2);
      }
      return asCallback(web3t.velas.NativeStaking.getCurrentEpochInfo(), function(err, epochInfo){
        if (err != null) {
          console.error(err);
        }
        store.staking.currentEpoch = epochInfo.epoch;
        return asCallback(web3t.velas.NativeStaking.getStakeActivation(store.staking.chosenAccount.address), function(err, stakeActivation){
          var wallet;
          if (err == null && stakeActivation != null) {
            store.staking.chosenAccount.status = stakeActivation.state;
            store.staking.chosenAccount.active_stake = stakeActivation.active;
            store.staking.chosenAccount.inactive_stake = stakeActivation.inactive;
          }
          if (err != null) {
            return alert(store, err, cb);
          }
          wallet = store.current.account.wallets.find(function(it){
            return it.coin.token === 'vlx_native';
          });
          if (wallet == null) {
            return alert(store, 'VLX Native wallet was not found', cb);
          }
          web3t.velas.NativeStaking.setAccountPublicKey(wallet.publicKey);
          web3t.velas.NativeStaking.setAccountSecretKey(wallet.secretKey);
          return cb(null);
        });
      });
    });
  };
  stringify = function(value){
    if (value != null) {
      return roundHuman(parseFloat(div(value, Math.pow(10, 18))));
    } else {
      return '..';
    }
  };
  fetchEpochRewards = function(address, activationEpoch, cb){
    if (store.staking.chosenAccount.validator == null || store.staking.chosenAccount.validator.toString().length === 0) {
      return cb(null, []);
    }
    return asCallback(web3t.velas.NativeStaking.getEpochSchedule(), function(err, epochSchedule){
      var firstNormalEpoch, firstNormalSlot, leaderScheduleSlotOffset, slotsPerEpoch, warmup;
      if (err != null) {
        console.error(err);
      }
      firstNormalEpoch = epochSchedule.firstNormalEpoch, firstNormalSlot = epochSchedule.firstNormalSlot, leaderScheduleSlotOffset = epochSchedule.leaderScheduleSlotOffset, slotsPerEpoch = epochSchedule.slotsPerEpoch, warmup = epochSchedule.warmup;
      return asCallback(web3t.velas.NativeStaking.getSlot(), function(err, slot){
        if (err != null) {
          console.error(err);
        }
        return asCallback(web3t.velas.NativeStaking.getFirstAvailableBlock(), function(err, firstAvailableBlock){
          if (err != null) {
            console.error(err);
          }
          return asCallback(web3t.velas.NativeStaking.getCurrentEpochInfo(), function(err, epochInfo){
            var epoch, blockHeight, slotIndex, slotsInEpoch, transactionCount;
            if (err != null) {
              console.error(err);
            }
            if (err != null) {
              return cb(null);
            }
            epoch = epochInfo.epoch, blockHeight = epochInfo.blockHeight, slotIndex = epochInfo.slotIndex, slotsInEpoch = epochInfo.slotsInEpoch, transactionCount = epochInfo.transactionCount;
            return queryRewardsLoop(address, activationEpoch, firstNormalSlot, slotsPerEpoch, slotsInEpoch, firstAvailableBlock, firstNormalEpoch, epoch, function(err, rewards){
              return cb(null, rewards);
            });
          });
        });
      });
    });
  };
  prevEpochData = {
    epoch_start_time: null,
    rewards: null,
    first_confirmed_block: null
  };
  queryRewardsLoop = function(address, activationEpoch, firstNormalSlot, slotsPerEpoch, slotsInEpoch, firstAvailableBlock, firstNormalEpoch, epoch, cb){
    if (epoch < activationEpoch || epoch < 0) {
      return cb(null, []);
    }
    if (store.staking.chosenAccount.stopLoadingRewards === true) {
      return cb(null, []);
    }
    if (store.staking.rewardsIndex >= store.staking.REWARDS_PER_PAGE) {
      return cb(null, []);
    }
    return get_first_slot_in_epoch(firstNormalSlot, slotsPerEpoch, slotsInEpoch, firstNormalEpoch, epoch, function(err, firstSlotInEpoch){
      var limit;
      limit = 1;
      return asCallback(web3t.velas.NativeStaking.getConfirmedBlocksWithLimit(firstSlotInEpoch, limit), function(err, result){
        var first_confirmed_block_in_epoch, ref$;
        first_confirmed_block_in_epoch = result != null ? (ref$ = result.result) != null ? ref$[0] : void 8 : void 8;
        return get_confirmed_block_with_encoding(first_confirmed_block_in_epoch, function(err, first_confirmed_block){
          var rewards, SECONDS_PER_DAY, epoch_start_time, epoch_end_time, wallclock_epoch_duration, wallclock_epochs_per_year, allRewards, ref$;
          rewards = [];
          SECONDS_PER_DAY = 86400;
          epoch_start_time = (function(){
            switch (false) {
            case first_confirmed_block != null:
              return 0;
            default:
              return first_confirmed_block.blockTime;
            }
          }());
          epoch_end_time = prevEpochData.epoch_start_time;
          wallclock_epoch_duration = (function(){
            switch (false) {
            case epoch_end_time != null:
              return 0;
            default:
              return minus(epoch_end_time, epoch_start_time);
            }
          }());
          wallclock_epochs_per_year = div(SECONDS_PER_DAY * 365.25, wallclock_epoch_duration);
          allRewards = (ref$ = prevEpochData.rewards) != null
            ? ref$
            : [];
          rewards = map(function(it){
            var percentChange, rateChange, apr;
            percentChange = times(div(it.lamports, it.postBalance), 100);
            percentChange = roundNumber(percentChange, {
              decimals: 2
            });
            rateChange = div(it.lamports, it.postBalance - it.lamports);
            apr = (function(){
              switch (false) {
              case epoch_end_time != null:
                return "0";
              default:
                return times(times(rateChange, wallclock_epochs_per_year), 100);
              }
            }());
            apr = roundNumber(apr, {
              decimals: 2
            });
            return {
              epoch: epoch,
              rewardSlot: prevEpochData.rewardSlot,
              amount: it.lamports,
              newBalance: it.postBalance,
              percentChange: percentChange + "%",
              apr: apr + "%",
              disabled: first_confirmed_block == null
            };
          })(
          filter(function(it){
            return it.pubkey === address;
          })(
          allRewards));
          if (rewards.length > 0) {
            store.staking.rewardsIndex++;
          }
          prevEpochData.first_confirmed_block = first_confirmed_block;
          prevEpochData.epoch_start_time = first_confirmed_block != null ? first_confirmed_block.blockTime : void 8;
          prevEpochData.rewards = first_confirmed_block != null ? first_confirmed_block.rewards : void 8;
          prevEpochData.rewardSlot = firstSlotInEpoch;
          return queryRewardsLoop(address, activationEpoch, firstNormalSlot, slotsPerEpoch, slotsInEpoch, firstAvailableBlock, firstNormalEpoch, --epoch, function(err, rest){
            var all;
            all = rewards.concat(rest);
            return cb(null, all);
          });
        });
      });
    });
  };
  get_first_slot_in_epoch = function(firstNormalSlot, slotsPerEpoch, slotsInEpoch, firstNormalEpoch, epoch, cb){
    var limit, firstSlotInEpoch;
    limit = 1;
    firstSlotInEpoch = (epoch - firstNormalEpoch) * slotsPerEpoch + firstNormalSlot;
    return cb(null, firstSlotInEpoch);
  };
  tryGetExtraSlot = function(defaultResponse, newSlot, cb){
    var limit;
    if (defaultResponse != null) {
      return cb(null, defaultResponse);
    }
    limit = 1;
    return asCallback(web3t.velas.NativeStaking.getConfirmedBlocksWithLimit(newSlot, limit), function(err, result){
      var ref$;
      return cb(null, result != null ? (ref$ = result.result) != null ? ref$[0] : void 8 : void 8);
    });
  };
  get_confirmed_block_with_encoding = function(slot, cb){
    var err;
    try {
      return asCallback(web3t.velas.NativeStaking.getConfirmedBlock(slot), function(err, confirmedBlock){
        if (err != null) {
          console.error(err);
        }
        if (err != null) {
          return cb(err);
        }
        return cb(null, confirmedBlock);
      });
    } catch (e$) {
      err = e$;
      return cb(err);
    }
  };
  retrieveRewardData = function(firstSlotInEpoch, firstNormalSlot, slotsPerEpoch, slotsInEpoch, firstAvailableBlock, firstNormalEpoch, epoch, cb){
    if (firstSlotInEpoch < firstAvailableBlock) {
      return cb("RPC node is out of history data");
    }
    return get_confirmed_block_with_encoding(firstSlotInEpoch, function(err, confirmed_block_with_encoding){
      return cb(null, confirmed_block_with_encoding);
    });
  };
  module.exports = accountDetails;
  function deepEq$(x, y, type){
    var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
        has = function (obj, key) { return hasOwnProperty.call(obj, key); };
    var first = true;
    return eq(x, y, []);
    function eq(a, b, stack) {
      var className, length, size, result, alength, blength, r, key, ref, sizeB;
      if (a == null || b == null) { return a === b; }
      if (a.__placeholder__ || b.__placeholder__) { return true; }
      if (a === b) { return a !== 0 || 1 / a == 1 / b; }
      className = toString.call(a);
      if (toString.call(b) != className) { return false; }
      switch (className) {
        case '[object String]': return a == String(b);
        case '[object Number]':
          return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
        case '[object Date]':
        case '[object Boolean]':
          return +a == +b;
        case '[object RegExp]':
          return a.source == b.source &&
                 a.global == b.global &&
                 a.multiline == b.multiline &&
                 a.ignoreCase == b.ignoreCase;
      }
      if (typeof a != 'object' || typeof b != 'object') { return false; }
      length = stack.length;
      while (length--) { if (stack[length] == a) { return true; } }
      stack.push(a);
      size = 0;
      result = true;
      if (className == '[object Array]') {
        alength = a.length;
        blength = b.length;
        if (first) {
          switch (type) {
          case '===': result = alength === blength; break;
          case '<==': result = alength <= blength; break;
          case '<<=': result = alength < blength; break;
          }
          size = alength;
          first = false;
        } else {
          result = alength === blength;
          size = alength;
        }
        if (result) {
          while (size--) {
            if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }
          }
        }
      } else {
        if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
          return false;
        }
        for (key in a) {
          if (has(a, key)) {
            size++;
            if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }
          }
        }
        if (result) {
          sizeB = 0;
          for (key in b) {
            if (has(b, key)) { ++sizeB; }
          }
          if (first) {
            if (type === '<<=') {
              result = size < sizeB;
            } else if (type === '<==') {
              result = size <= sizeB
            } else {
              result = size === sizeB;
            }
          } else {
            first = false;
            result = size === sizeB;
          }
        }
      }
      stack.pop();
      return result;
    }
  }
}).call(this);
