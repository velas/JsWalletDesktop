// Generated by LiveScript 1.6.0
(function(){
  var react, reactDom, navigate, getPrimaryInfo, web3, bignumber, getLang, historyFuncs, ref$, queryPools, getMyStakes, queryAccounts, convertPoolsToViewModel, convertAccountsToViewModel, filterPools, subscribeToStakeAccount, icon, map, split, filter, find, foldl, sortBy, unique, head, each, objToPairs, take, reverse, findIndex, div, times, plus, minus, hdkey, bip39, md5, menuFuncs, btoa, Buffer, copiedInform, copy, round5, switchAccount, roundHuman, icons, placeholder, claimStake, epoch, alert, button, addressHolder, addressHolderPopup, pagination, alertTxn, amountField, seedmem, burger, stakeAccounts, calcCertainWallet, calcWallet, decode, velasWeb3, paginate, cb, asCallback, showValidator, stakingContent, validators, stringify, out$ = typeof exports != 'undefined' && exports || this, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};
  react = require('react');
  reactDom = require('react-dom');
  navigate = require('../navigate.ls');
  getPrimaryInfo = require('../get-primary-info.ls');
  web3 = require('../web3.ls');
  bignumber = require('bignumber.js');
  getLang = require('../get-lang.ls');
  historyFuncs = require('../history-funcs.ls');
  ref$ = require('../staking-funcs.ls'), queryPools = ref$.queryPools, getMyStakes = ref$.getMyStakes, queryAccounts = ref$.queryAccounts, convertPoolsToViewModel = ref$.convertPoolsToViewModel, convertAccountsToViewModel = ref$.convertAccountsToViewModel, filterPools = ref$.filterPools, subscribeToStakeAccount = ref$.subscribeToStakeAccount;
  icon = require('./icon.ls');
  ref$ = require('prelude-ls'), map = ref$.map, split = ref$.split, filter = ref$.filter, find = ref$.find, foldl = ref$.foldl, sortBy = ref$.sortBy, unique = ref$.unique, head = ref$.head, each = ref$.each, objToPairs = ref$.objToPairs, take = ref$.take, reverse = ref$.reverse, findIndex = ref$.findIndex;
  ref$ = require('../math.ls'), div = ref$.div, times = ref$.times, plus = ref$.plus, minus = ref$.minus;
  ref$ = require('../../web3t/providers/deps.js'), hdkey = ref$.hdkey, bip39 = ref$.bip39;
  md5 = require('md5');
  menuFuncs = require('../menu-funcs.ls');
  btoa = require('btoa');
  Buffer = require('safe-buffer').Buffer;
  copiedInform = require('../copied-inform.ls');
  copy = require('../copy.ls');
  round5 = require('../round5.ls');
  switchAccount = require('./switch-account.ls');
  roundHuman = require('../round-human.ls');
  icons = require('../icons.ls');
  placeholder = require('./placeholder.ls');
  claimStake = require('./claim-stake.ls');
  epoch = require('./epoch.ls');
  alert = require('./confirmation.ls').alert;
  button = require('../components/button.ls');
  addressHolder = require('../components/address-holder.ls');
  addressHolderPopup = require('../components/address-holder-popup.ls');
  pagination = require('../components/pagination.ls');
  alertTxn = require('./alert-txn.ls');
  amountField = require('../components/amount-field.ls');
  seedmem = require('../seed.ls');
  burger = require('../components/burger.ls');
  stakeAccounts = require('./stake/accounts.ls');
  calcCertainWallet = require('../calc-certain-wallet.ls');
  calcWallet = require('../calc-wallet.ls');
  decode = require('bs58').decode;
  velasWeb3 = require('../../web3t/providers/solana/index.cjs');
  out$.paginate = paginate = function(array, perPage, page){
    page = page - 1;
    return array.slice(page * perPage, (page + 1) * perPage);
  };
  cb = console.log;
  asCallback = function(p, cb){
    p['catch'](function(err){
      return cb(err);
    });
    return p.then(function(data){
      return cb(null, data);
    });
  };
  showValidator = function(store, web3t){
    return function(validator){
      return react.createElement('li', {
        key: "validator-" + validator
      }, ' ' + validator);
    };
  };
  stakingContent = function(store, web3t){
    var goBack, style, lang, buttonPrimary3Style, filterIcon, commingSoon, iStakeChoosenPool, ref$, accountLeft, accountRight, changeAccountIndex, lineStyle, getBalance, getOptions, useMin, useMax, yourBalance, yourStakingAmount, yourStaking, vlxToken, isSpinned, buildStaker, cancelPool, updatePoolsAndAccounts, refresh, iconStyle, stakerPoolStyle, stats, totalValidators, allPages, loadingValidatorIndex, perPage, page, paginationDisabled, children;
    goBack = historyFuncs(store, web3t).goBack;
    style = getPrimaryInfo(store);
    lang = getLang(store);
    buttonPrimary3Style = {
      border: "1px solid " + style.app.primary3,
      color: style.app.text2,
      background: style.app.primary3,
      backgroundColor: style.app.primary3Spare
    };
    filterIcon = {
      filter: style.app.filterIcon
    };
    commingSoon = {
      opacity: ".3"
    };
    iStakeChoosenPool = function(){
      var pool, myStake;
      pool = store.staking.chosenPool;
      myStake = +pool.myStake;
      return myStake >= 10000;
    };
    ref$ = menuFuncs(store, web3t), accountLeft = ref$.accountLeft, accountRight = ref$.accountRight, changeAccountIndex = ref$.changeAccountIndex;
    lineStyle = {
      padding: "10px",
      width: '100%'
    };
    getBalance = function(){
      var wallet;
      wallet = find(function(it){
        return it.coin.token === 'vlx_native';
      })(
      store.current.account.wallets);
      return wallet.balance;
    };
    getOptions = function(cb){
      var iAmStaker;
      iAmStaker = iStakeChoosenPool();
      if (iAmStaker) {
        return cb(null);
      }
      return web3t.velas.Staking.candidateMinStake(function(err, data){
        var min, balance, stake, max;
        if (err != null) {
          return cb(err);
        }
        min = (function(){
          switch (false) {
          case !(+store.staking.stakeAmountTotal >= 10000):
            return 1;
          default:
            return div(data, Math.pow(10, 18));
          }
        }());
        balance = minus(getBalance(), 0.1);
        stake = store.staking.add.addValidatorStake;
        if (10000 > +stake) {
          return cb(lang.amountLessStaking);
        }
        if (+balance < +stake) {
          return cb(lang.balanceLessStaking);
        }
        max = +balance;
        return cb(null, {
          min: min,
          max: max
        });
      });
    };
    useMin = function(){
      return store.staking.add.addValidatorStake = 10000;
    };
    useMax = function(){
      return store.staking.add.addValidatorStake = Math.max(minus(getBalance(), 0.1), 0);
    };
    yourBalance = " " + roundHuman(getBalance()) + " ";
    yourStakingAmount = div(store.staking.stakeAmountTotal, Math.pow(10, 18));
    yourStaking = " " + roundHuman(yourStakingAmount);
    vlxToken = "VLX";
    isSpinned = (store.staking.allPoolsLoaded === false || store.staking.allPoolsLoaded == null) && store.staking.poolsAreLoading === true ? "spin disabled" : "";
    buildStaker = function(store, web3t){
      return function(item){
        var checked, stake, isDelinquent, $stake, myStake, buildMyStake, fee, lastVote, index, reward, filled, filledColor, delinquentClass, vlx_native, wallet, votePower, mystakeClass, children;
        checked = item.checked;
        stake = item.stakeInitial;
        isDelinquent = item.status === "delinquent";
        $stake = roundHuman(stake, {
          decimals: 2
        });
        myStake = (function(){
          switch (false) {
          case +item.myStake.length !== 0:
            return [];
          default:
            return item.myStake;
          }
        }());
        buildMyStake = function(stake){
          var showDetails, children;
          showDetails = function(){
            var account;
            account = find(function(it){
              return it.seed === stake.seed;
            })(
            store.staking.accounts);
            if (account == null) {
              return null;
            }
            store.staking.chosenAccount = account;
            return navigate(store, web3t, 'account_details');
          };
          return react.createElement('div', {
            onClick: showDetails,
            className: "stake-item"
          }, children = react.createElement('div', {
            className: 'name'
          }, children = react.createElement('span', {}, ' ' + stake.seed)));
        };
        fee = item.commission;
        lastVote = item.lastVote;
        index = store.staking.pools.indexOf(item) + 1;
        reward = (function(){
          switch (false) {
          case item.validatorRewardPercent !== "..":
            return "..";
          default:
            return (100 - +item.validatorRewardPercent) * 1.4285714286;
          }
        }());
        filled = roundHuman(reward) + "%";
        filledColor = {
          color: (function(){
            switch (false) {
            case !(reward > 95):
              return 'red';
            case !(reward > 75):
              return 'orange';
            case !(reward > 40):
              return "rgb(165, 174, 81)";
            default:
              return "rgb(38, 219, 85)";
            }
          }())
        };
        delinquentClass = (function(){
          switch (false) {
          case !isDelinquent:
            return "delinquent";
          default:
            return "";
          }
        }());
        vlx_native = find(function(it){
          return it.coin.token === 'vlx_native';
        })(
        store.current.account.wallets);
        if (vlx_native == null) {
          return null;
        }
        wallet = {
          address: item.address,
          network: vlx_native.network,
          coin: vlx_native.coin
        };
        votePower = (function(){
          switch (false) {
          case item.votePower == null:
            return item.votePower + "%";
          default:
            return "...";
          }
        }());
        mystakeClass = myStake !== 0 ? "with-stake" : "";
        return react.createElement('tr', {
          key: "validator-item-" + item.address,
          className: "validator-item " + item.status + " " + delinquentClass
        }, children = [
          react.createElement('td', {
            datacolumn: 'Staker Address',
            title: item.address + ""
          }, children = addressHolderPopup({
            store: store,
            wallet: wallet
          })), react.createElement('td', {}, ' ' + $stake), react.createElement('td', {}, ' ' + fee + '%'), react.createElement('td', {}, ' ' + lastVote), react.createElement('td', {
            className: mystakeClass + ""
          }, children = map(buildMyStake)(
          myStake)), react.createElement('td', {}, ' ' + item.stakers)
        ]);
      };
    };
    cancelPool = function(){
      return store.staking.chosenPool = null;
    };
    updatePoolsAndAccounts = function(cb){
      if (store.staking.accounts.length > 0) {
        return;
      }
      store.staking.allAccountsLoaded = false;
      store.staking.accountsAreLoading = true;
      store.staking.accounts = [];
      return validators.init({
        store: store,
        web3t: web3t
      }, function(err){
        if (err != null) {
          return cb(err);
        }
        return cb(null);
      });
    };
    refresh = function(){
      var cb;
      store.staking.getAccountsFromCashe = false;
      store.staking.allPoolsLoaded = false;
      if ((store.staking.allPoolsLoaded === false || store.staking.allPoolsLoaded == null) && store.staking.poolsAreLoading === true) {
        return false;
      }
      store.staking.poolsAreLoading = true;
      cb = console.log;
      store.staking.pools = [];
      store.staking.delegators = {};
      return updatePoolsAndAccounts(function(){
        return cb(null, 'done');
      });
    };
    iconStyle = {
      color: style.app.loader,
      marginTop: "10px",
      width: "inherit"
    };
    stakerPoolStyle = {
      maxWidth: 200,
      background: style.app.stats
    };
    stats = {
      background: style.app.stats
    };
    totalValidators = (ref$ = store.staking.totalValidators) != null ? ref$ : 0;
    allPages = Math.ceil(div(totalValidators, store.staking.validators_per_page));
    loadingValidatorIndex = store.staking.loadingValidatorIndex;
    perPage = store.staking.validators_per_page;
    page = store.staking.current_validators_page;
    paginationDisabled = store.staking.poolsAreLoading === true;
    return react.createElement('div', {
      className: 'staking-content delegate'
    }, children = react.createElement('div', {
      className: 'main-sections'
    }, children = [
      react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h2', {}, ' ' + lang.balance)), react.createElement('div', {
          className: 'description'
        }, children = react.createElement('span', {
          id: "vlx-native-balance"
        }, ' ' + yourBalance + ' VLX'))
      ]), stakeAccounts({
        store: store,
        web3t: web3t
      }), react.createElement('div', {
        id: "pools",
        className: 'form-group'
      }, children = [
        alertTxn({
          store: store
        }), react.createElement('div', {
          className: 'section'
        }, children = [
          react.createElement('div', {
            className: 'title'
          }, children = [
            react.createElement('h3', {
              className: 'section-title'
            }, ' ' + lang.validators + ' '), react.createElement('span', {
              className: 'amount'
            }, ' (' + store.staking.pools.length + ')')
          ]), react.createElement('div', {
            className: 'description'
          }, children = store.errors.fetchValidators != null
            ? react.createElement('div', {
              className: 'error'
            }, children = [
              react.createElement('span', {
                className: 'warning-icon'
              }, ' ⚠️'), react.createElement('div', {
                className: 'message'
              }, ' An error occurred during fetching validators. Please try one more time...')
            ])
            : react.createElement('div', {
              className: 'cont'
            }, children = [
              store.staking.poolsAreLoading === false ? react.createElement('div', {
                className: 'table-scroll'
              }, children = react.createElement('table', {}, children = [
                react.createElement('thead', {}, children = react.createElement('tr', {}, children = [
                  react.createElement('td', {
                    width: "30%",
                    style: stakerPoolStyle,
                    title: "Validator Staking Address. Permanent"
                  }, ' ' + lang.validator + ' (?)'), react.createElement('td', {
                    width: "15%",
                    style: stats,
                    title: "Sum of all stakings"
                  }, ' ' + lang.totalActiveStake + ' (?)'), react.createElement('td', {
                    width: "5%",
                    style: stats,
                    title: "Validator Interest. (100% - Validator Interest = Pool Staking Reward)"
                  }, ' ' + lang.comission + ' (?)'), react.createElement('td', {
                    width: "10%",
                    style: stats,
                    title: "Last Staking Amount"
                  }, ' ' + lang.lastVote + ' (?)'), react.createElement('td', {
                    width: "10%",
                    style: stats,
                    title: "Find you staking by Seed"
                  }, ' ' + lang.myStake + ' (?)'), react.createElement('td', {
                    width: "5%",
                    style: stats,
                    title: "How many stakers in a pool"
                  }, ' ' + lang.stakers + ' (?)')
                ])), react.createElement('tbody', {}, children = map(buildStaker(store, web3t))(
                paginate(store.staking.pools, perPage, store.staking.current_validators_page)))
              ])) : void 8, store.staking.poolsAreLoading === false
                ? pagination({
                  store: store,
                  type: 'validators',
                  disabled: paginationDisabled,
                  config: {
                    array: store.staking.pools
                  }
                })
                : react.createElement('div', {
                  className: 'table-scroll'
                }, children = react.createElement('span', {
                  className: 'entities-loader'
                }, children = react.createElement('span', {
                  className: 'inner-section'
                }, children = [
                  react.createElement('h3', {
                    className: 'item blink'
                  }, ' Loading...'), false ? (react.createElement('span', {
                    className: 'item'
                  }, '  ' + store.staking.loadingValidatorIndex), react.createElement('span', {
                    className: 'item'
                  }, ' of'), react.createElement('span', {
                    className: 'item'
                  }, '  ' + totalValidators)) : void 8
                ])))
            ]))
        ])
      ])
    ]));
  };
  validators = function(arg$){
    var store, web3t, lang, goBack, wallet, gotoSearch, info, style, titleStyle, borderStyle, borderStyle2, borderRight, headerTableStyle, lightText, iconColor, showClass, children;
    store = arg$.store, web3t = arg$.web3t;
    lang = getLang(store);
    goBack = historyFuncs(store, web3t).goBack;
    wallet = find(function(it){
      return it.coin.token === 'vlx_native';
    })(
    store.current.account.wallets);
    if (wallet == null) {
      return cb(null);
    }
    gotoSearch = function(){
      return navigate(store, web3t, 'search');
    };
    info = getPrimaryInfo(store);
    style = {
      background: info.app.wallet,
      color: info.app.text
    };
    titleStyle = {
      zIndex: 3,
      color: info.app.text,
      borderBottom: "1px solid " + info.app.border,
      background: info.app.background,
      backgroundColor: info.app.bgspare
    };
    borderStyle = {
      color: info.app.text,
      borderBottom: "1px solid " + info.app.border,
      background: info.app.background,
      backgroundColor: info.app.bgspare
    };
    borderStyle2 = {
      color: info.app.text,
      borderBottom: "1px solid " + info.app.border,
      background: "#4b2888"
    };
    borderRight = {
      color: info.app.text,
      borderRight: "1px solid " + info.app.border
    };
    headerTableStyle = {
      borderBottom: "1px solid " + info.app.border,
      background: info.app.walletLight
    };
    lightText = {
      color: info.app.color3
    };
    iconColor = {
      filter: info.app.iconFilter
    };
    showClass = store.current.openMenu ? 'hide' : "";
    return react.createElement('div', {
      className: 'staking staking-1524468490'
    }, children = [
      react.createElement('div', {
        style: titleStyle,
        className: 'title'
      }, children = [
        react.createElement('div', {
          className: showClass + " header"
        }, ' ' + lang.delegateStake), react.createElement('div', {
          onClick: goBack,
          className: 'close'
        }, children = react.createElement('img', {
          src: icons.arrowLeft + "",
          style: iconColor,
          className: 'icon-svg'
        })), burger(store, web3t), epoch(store, web3t), switchAccount(store, web3t)
      ]), stakingContent(store, web3t)
    ]);
  };
  stringify = function(value){
    if (value != null) {
      return roundHuman(parseFloat(div(value, Math.pow(10, 18))));
    } else {
      return '..';
    }
  };
  validators.init = function(arg$, cb){
    var store, web3t;
    store = arg$.store, web3t = arg$.web3t;
    calcCertainWallet(store, 'vlx_native', function(err){
      var random, wallet, publicKey, callback, commitment, id, indexIsDifferent;
      if (store.staking.fetchAccounts === false) {
        store.staking.fetchAccounts = true;
        return cb(null);
      }
      store.staking.maxWithdraw = 0;
      random = function(){
        return Math.random();
      };
      store.current.page = "validators";
      store.staking.current_validators_page = 1;
      store.staking.pools = [];
      store.staking.poolsFiltered = [];
      store.staking.accounts = [];
      store.staking.delegators = {};
      store.staking.withdrawAmount = 0;
      store.staking.stakeAmountTotal = 0;
      store.staking.reward = null;
      store.staking.allPoolsLoaded = false;
      store.staking.poolsAreLoading = true;
      store.staking.allAccountsLoaded = false;
      store.staking.accountsAreLoading = true;
      store.staking.chosenPool = null;
      store.staking.add.addValidatorStake = 0;
      store.staking.loadingAccountIndex = 0;
      store.staking.loadingValidatorIndex = 0;
      store.staking.splittingStakingAccount = false;
      store.staking.creatingStakingAccount = false;
      store.staking.subscribedAccounts = {};
      wallet = find(function(it){
        return it.coin.token === 'vlx_native';
      })(
      store.current.account.wallets);
      try {
        publicKey = new velasWeb3.PublicKey(wallet.publicKey);
        callback = function(res){};
        commitment = 'finalized';
        id = web3t.velas.NativeStaking.connection.onAccountChange(publicKey, callback, commitment);
        store.staking.webSocketAvailable = true;
      } catch (e$) {
        err = e$;
        console.log("ws onAccountChange err: ", err);
        store.staking.webSocketAvailable = false;
      }
      indexIsDifferent = store.current.accountIndex !== store.staking.accountIndex;
      if (store.staking.poolsNetwork === store.current.network) {
        if (store.staking.allPoolsLoaded != null && store.staking.allPoolsLoaded === true && !indexIsDifferent) {
          return cb(null);
        }
      } else {
        store.staking.poolsNetwork = store.current.network;
      }
      return asCallback(web3t.velas.NativeStaking.getCurrentEpochInfo(), function(err, epochInfo){
        var epoch;
        if (err != null) {
          console.error(err);
        }
        epoch = epochInfo != null ? epochInfo.epoch : void 8;
        store.staking.currentEpoch = epoch;
        store.staking.pools = [];
        return asCallback(web3t.velas.NativeStaking.connection.getMinimumBalanceForRentExemption(200), function(err, rent){
          var onProgress;
          if (err != null) {
            rent = 2282880;
          }
          rent = div(rent, Math.pow(10, 9));
          store.staking.rent = rent;
          if (wallet == null) {
            return cb(null);
          }
          web3t.velas.NativeStaking.setAccountPublicKey(wallet.publicKey);
          web3t.velas.NativeStaking.setAccountSecretKey(wallet.secretKey);
          onProgress = function(){};
          return queryAccounts(store, web3t, onProgress, function(err, result){
            var type, page, ref$, perPage, onProgress;
            if (err != null) {
              store.staking.allAccountsLoaded = true;
              store.staking.accountsAreLoading = false;
              console.error("[query-accounts] err", err);
              if (err != null) {
                result = [];
              }
              store.errors.fetchAccounts = {
                message: err
              };
            }
            store.staking.accounts = result;
            try {
              each(function(account){
                var publicKey;
                publicKey = account.pubKey;
                return subscribeToStakeAccount({
                  store: store,
                  web3t: web3t,
                  account: account,
                  publicKey: publicKey
                });
              })(
              store.staking.accounts);
            } catch (e$) {
              err = e$;
              console.log("err", err);
              store.staking.webSocketAvailable = false;
            }
            type = "accounts";
            page = (ref$ = store.staking["current_" + type + "_page"]) != null ? ref$ : 1;
            perPage = store.staking[type + "_per_page"];
            if (+times(page, perPage) >= store.staking.accounts.length) {
              store.staking["current_" + type + "_page"] = 1;
            }
            onProgress = function(it){
              return store.staking.pools = convertPoolsToViewModel(arrayFrom$(it));
            };
            return queryPools({
              store: store,
              web3t: web3t,
              onProgress: onProgress
            }, function(err, pools){
              if (err != null) {
                store.staking.allPoolsLoaded = true;
                store.staking.poolsAreLoading = false;
                console.log("[query-pools] err", err);
                if (err != null) {
                  pools = [];
                }
                store.errors.fetchValidators = {
                  message: err
                };
              }
              filterPools(pools);
              store.staking.poolsFiltered = store.staking.pools;
              return store.staking.getAccountsFromCashe = false;
            });
          });
        });
      });
    });
  };
  module.exports = validators;
}).call(this);
