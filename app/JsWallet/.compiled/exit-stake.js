// Generated by LiveScript 1.6.0
(function(){
  var react, reactDom, getPrimaryInfo, web3, getLang, icons, ref$, div, times, plus, minus, canMakeStaking, amountField, button, alert, cb, orderWithdrawProcess, fastWithdrawProcess, notAvailableRightNow, registry;
  react = require('react');
  reactDom = require('react-dom');
  getPrimaryInfo = require('../get-primary-info.ls');
  web3 = require('../web3.ls');
  getLang = require('../get-lang.ls');
  icons = require('../icons.ls');
  ref$ = require('../math.ls'), div = ref$.div, times = ref$.times, plus = ref$.plus, minus = ref$.minus;
  canMakeStaking = require('../staking/can-make-staking.ls');
  amountField = require('../components/amount-field.ls');
  button = require('../components/button.ls');
  alert = require('./confirmation.ls').alert;
  cb = bind$(console, 'log');
  orderWithdrawProcess = function(store, web3t){
    var lang, activate, activateFirst, activateSecond, activateThird, activeClass, activeFirst, activeSecond, activeThird, order, exit, changeMax, epochNext, ref$, children;
    lang = getLang(store);
    activate = function(step){
      return function(){
        return store.staking.exitTab = step;
      };
    };
    activateFirst = activate('exit_order');
    activateSecond = activate('exit_wait');
    activateThird = activate('exit_ordered');
    activeClass = function(step){
      if (store.staking.exitTab === step) {
        return 'active';
      } else {
        return '';
      }
    };
    activeFirst = activeClass('exit_order');
    activeSecond = activeClass('exit_wait');
    activeThird = activeClass('exit_ordered');
    order = function(){
      return web3t.velas.Staking.areStakeAndWithdrawAllowed(function(err, data){
        var stakingAddress, poolAddress;
        if (err != null) {
          return cb(err);
        }
        if (data !== true) {
          return alert(store, lang.exitNotAllowed, cb);
        }
        stakingAddress = store.staking.keystore.staking.address;
        poolAddress = store.staking.chosenPool.address;
        return web3t.velas.Staking.maxWithdrawOrderAllowed(poolAddress, stakingAddress, function(err, max){
          var amount, data, to;
          amount = times(store.staking.withdrawAmount, Math.pow(10, 18));
          if (+amount > +max.toFixed()) {
            return alert(store, lang.max + " " + div(max.toFixed(), Math.pow(10, 18)));
          }
          if (+amount === 0) {
            return alert(store, lang.actionProhibited, cb);
          }
          data = web3t.velas.Staking.orderWithdraw.getData(poolAddress, amount);
          to = web3t.velas.Staking.address;
          amount = 0;
          return web3t.vlx2.sendTransaction({
            to: to,
            data: data,
            amount: amount,
            gas: 4600000,
            gasPrice: 1000000
          }, function(err){});
        });
      });
    };
    exit = function(){
      var poolAddress, data, to, amount;
      if (+store.staking.orderedWithdrawAmount === 0) {
        return alert(store, lang.actionProhibited, cb);
      }
      poolAddress = store.staking.chosenPool.address;
      data = web3t.velas.Staking.claimOrderedWithdraw.getData(poolAddress);
      to = web3t.velas.Staking.address;
      amount = 0;
      return web3t.vlx2.sendTransaction({
        to: to,
        data: data,
        amount: amount,
        gas: 4600000,
        gasPrice: 1000000
      }, function(err){});
    };
    changeMax = function(it){
      return store.staking.withdrawAmount = it.target.value;
    };
    epochNext = (ref$ = store.dashboard.epochNext) != null ? ref$ : 'loading...';
    return react.createElement('div', {
      className: 'section'
    }, children = [
      react.createElement('div', {
        className: 'title'
      }, children = react.createElement('h3', {}, ' ' + lang.exit)), react.createElement('div', {
        className: 'description'
      }, children = react.createElement('div', {
        className: 'left'
      }, children = react.createElement('div', {
        className: 'steps steps2030851689'
      }, children = [
        react.createElement('div', {
          onClickCommented: activateFirst,
          className: activeFirst + " step"
        }, children = [
          react.createElement('div', {
            className: 'step-count'
          }, ' 1'), react.createElement('div', {
            className: 'step-content'
          }, children = [
            react.createElement('div', {}, ' ' + lang.requestExit), activeFirst === 'active' ? react.createElement('div', {}, children = [
              react.createElement('div', {}, children = amountField({
                store: store,
                value: store.staking.withdrawAmount,
                onChange: changeMax
              })), button({
                store: store,
                text: lang.requestExit,
                icon: 'exit',
                onClick: order,
                type: "secondary"
              })
            ]) : void 8
          ])
        ]), react.createElement('div', {
          onClickCommented: activateSecond,
          className: activeSecond + " step"
        }, children = [
          react.createElement('div', {
            className: 'step-count'
          }, ' 2'), react.createElement('div', {
            className: 'step-content'
          }, ' ' + lang.comeBack)
        ]), react.createElement('div', {
          onClickCommented: activateThird,
          className: activeThird + " step"
        }, children = [
          react.createElement('div', {
            className: 'step-count'
          }, ' 3'), react.createElement('div', {
            className: 'step-content'
          }, children = [
            react.createElement('div', {}, ' ' + lang.withdraw), activeThird === 'active' ? button({
              store: store,
              text: lang.withdraw,
              icon: 'exit',
              onClick: exit,
              type: "secondary"
            }) : void 8
          ])
        ])
      ])))
    ]);
  };
  fastWithdrawProcess = function(store, web3t){
    var lang, exit, changeMax, children;
    lang = getLang(store);
    exit = function(){
      return canMakeStaking(store, web3t, function(err){
        var myStake, stakingAddress, poolAddress;
        if (err != null) {
          return alert(store, err, cb);
        }
        myStake = store.staking.chosenPool.myStake ? div(store.staking.chosenPool.myStake, Math.pow(10, 18)) : 0;
        stakingAddress = store.staking.keystore.staking.address;
        poolAddress = store.staking.chosenPool.address;
        return web3t.velas.Staking.maxWithdrawAllowed(poolAddress, stakingAddress, function(err, max){
          var myStake, amount, data, to;
          if (!myStake) {
            myStake = max;
          }
          amount = times(store.staking.withdrawAmount, Math.pow(10, 18));
          if (+amount > +max.toFixed()) {
            return alert(store, "Max amount to withdraw is " + div(max, Math.pow(10, 18)));
          }
          if (+myStake - +store.staking.withdrawAmount !== 0) {
            if (+myStake - +store.staking.withdrawAmount < 10000) {
              return alert(store, "The pool stake amount after withdraw " + store.staking.withdrawAmount + " VLX must be at least 10000 VLX or no stake at all.", cb);
            }
          }
          if (+amount === 0) {
            return alert(store, lang.actionProhibited, cb);
          }
          data = web3t.velas.Staking.withdraw.getData(poolAddress, amount);
          to = web3t.velas.Staking.address;
          amount = 0;
          return web3t.vlx2.sendTransaction({
            to: to,
            data: data,
            amount: amount,
            gas: 4600000,
            gasPrice: 1000000
          }, function(err){});
        });
      });
    };
    changeMax = function(it){
      return store.staking.withdrawAmount = it.target.value;
    };
    return react.createElement('div', {
      className: 'section'
    }, children = [
      react.createElement('div', {
        className: 'title'
      }, children = react.createElement('h3', {}, ' ' + lang.exit)), react.createElement('div', {
        className: 'description'
      }, children = [
        react.createElement('div', {}, ' ' + lang.withdraw), react.createElement('div', {}, children = amountField({
          store: store,
          value: store.staking.withdrawAmount,
          onChange: changeMax
        })), button({
          store: store,
          text: lang.withdraw,
          icon: 'exit',
          onClick: exit,
          type: "secondary"
        })
      ])
    ]);
  };
  notAvailableRightNow = function(store){
    var lang, children;
    lang = getLang(store);
    return react.createElement('div', {
      className: 'section'
    }, children = [
      react.createElement('div', {
        className: 'title'
      }, children = react.createElement('h3', {}, ' ' + lang.exit)), react.createElement('div', {
        className: 'description'
      }, children = react.createElement('div', {}, ' ' + lang.actionProhibited))
    ]);
  };
  registry = {
    'exit_ordered': orderWithdrawProcess,
    'exit_order': orderWithdrawProcess,
    'exit_wait': orderWithdrawProcess,
    'exit': fastWithdrawProcess,
    'exit_closed': notAvailableRightNow
  };
  module.exports = function(store, web3t){
    var func;
    func = registry[store.staking.exitTab];
    if (func == null) {
      return null;
    }
    return func(store, web3t);
  };
  module.exports.init = function(arg$, cb){
    var store, web3t, stakingAddress, ref$, poolAddress;
    store = arg$.store, web3t = arg$.web3t;
    store.staking.exitTab = '';
    store.staking.maxWithdrawAllowed = 0;
    store.staking.maxWithdrawOrderAllowed = 0;
    store.staking.orderedWithdrawAmount = 0;
    stakingAddress = store.staking.keystore.staking.address;
    if (((ref$ = store.staking) != null ? ref$.chosenPool : void 8) == null) {
      return cb(null);
    }
    poolAddress = store.staking.chosenPool.address;
    return web3t.velas.Staking.maxWithdrawAllowed(poolAddress, stakingAddress, function(err, max){
      if (err != null) {
        return cb(err);
      }
      store.staking.maxWithdrawAllowed = div(max.toFixed(), Math.pow(10, 18));
      if (+store.staking.maxWithdrawAllowed > 0) {
        store.staking.withdrawAmount = store.staking.maxWithdrawAllowed;
      }
      return web3t.velas.Staking.maxWithdrawOrderAllowed(poolAddress, stakingAddress, function(err, max){
        if (err != null) {
          return cb(err);
        }
        store.staking.maxWithdrawOrderAllowed = div(max.toFixed(), Math.pow(10, 18));
        if (+store.staking.maxWithdrawOrderAllowed > 0) {
          store.staking.withdrawAmount = store.staking.maxWithdrawOrderAllowed;
        }
        return web3t.velas.Staking.orderedWithdrawAmount(store.staking.chosenPool.address, stakingAddress, function(err, amount){
          if (err != null) {
            return cb(err);
          }
          store.staking.orderedWithdrawAmount = amount.toFixed();
          return web3t.velas.Staking.orderWithdrawEpoch(store.staking.chosenPool.address, stakingAddress, function(err, lastEpoch){
            if (err != null) {
              return cb(err + "");
            }
            return web3t.velas.Staking.stakingEpoch(function(err, stakingEpoch){
              var res;
              if (err != null) {
                return cb(err + "");
              }
              res = minus(stakingEpoch, lastEpoch);
              store.staking.waitForEpochChange = +res === 0 ? true : false;
              store.staking.exitTab = (function(){
                switch (false) {
                case !(+store.staking.orderedWithdrawAmount > 0 && store.staking.waitForEpochChange):
                  return 'exit_wait';
                case !(+store.staking.orderedWithdrawAmount > 0):
                  return 'exit_ordered';
                case !(+store.staking.maxWithdrawAllowed > 0):
                  return 'exit';
                case !(+store.staking.maxWithdrawOrderAllowed > 0):
                  return 'exit_order';
                case !(+store.staking.stakeAmountTotal > 0):
                  return 'exit_closed';
                default:
                  return '';
                }
              }());
              return cb(null);
            });
          });
        });
      });
    });
  };
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);
