// Generated by LiveScript 1.6.0
(function(){
  var toJS, ref$, times, minus, div, createTransaction, pushTx, changeAmount, calcCryptoFromEur, calcCryptoFromUsd, notifyFormResult, getNameMask, resolveAddress, window, navigate, close, round, round5, round5edit, topup, getPrimaryInfo, createPendingTx, rebuildHistory, map, web3, calcFee, confirm, getLang, applyTransactions, getTxDetails, out$ = typeof exports != 'undefined' && exports || this;
  toJS = require('mobx').toJS;
  ref$ = require('./math.ls'), times = ref$.times, minus = ref$.minus, div = ref$.div;
  ref$ = require('./api.ls'), createTransaction = ref$.createTransaction, pushTx = ref$.pushTx;
  ref$ = require('./calc-amount.ls'), changeAmount = ref$.changeAmount, calcCryptoFromEur = ref$.calcCryptoFromEur, calcCryptoFromUsd = ref$.calcCryptoFromUsd;
  notifyFormResult = require('./send-form.ls').notifyFormResult;
  getNameMask = require('./get-name-mask.ls');
  resolveAddress = require('./resolve-address.ls');
  window = require('./browser/window.ls');
  navigate = require('./navigate.ls');
  close = require('./close.ls');
  round = require('./round.ls');
  round5 = require('./round5.ls');
  round5edit = require('./round5edit.ls');
  topup = require('./topup.ls');
  getPrimaryInfo = require('./get-primary-info.ls');
  createPendingTx = require('./pending-tx.ls').createPendingTx;
  rebuildHistory = require('./transactions.ls').rebuildHistory;
  map = require('prelude-ls').map;
  web3 = require('./web3.ls');
  calcFee = require('./api.ls').calcFee;
  confirm = require('./pages/confirmation.ls').confirm;
  getLang = require('./get-lang.ls');
  applyTransactions = require('./apply-transactions.ls');
  getTxDetails = require('./get-tx-details.ls');
  module.exports = function(store, web3t){
    var lang, sendTo, send, wallet, feeType, color, primaryButtonStyle, defaultButtonStyle, sendTx, performSendSafe, performSendUnsafe, checkEnough, sendMoney, sendEscrow, sendAnyway, cancel, recipientChange, getValue, amountChange, performAmountEurChange, performAmountUsdChange, amountEurChange, amountUsdChange, encodeDecode, showData, showLabel, whenEmpty, history, network, invoice, token, name, ref$, feeToken, isData, chooseAuto, chooseCheap, chooseCustom, chosenCheap, chosenAuto, chosenCustom, sendOptions, pending, calcAmountAndFee, useMax, useMaxTryCatch, useMaxAmount;
    if (store == null || web3t == null) {
      return null;
    }
    lang = getLang(store);
    sendTo = web3t.naming.sendTo;
    send = store.current.send;
    wallet = send.wallet, feeType = send.feeType;
    if (wallet == null) {
      return null;
    }
    color = getPrimaryInfo(store).color;
    primaryButtonStyle = {
      background: color
    };
    defaultButtonStyle = {
      color: color
    };
    sendTx = function(arg$, cb){
      var to, wallet, network, amountSend, amountSendFee, data, coin, txType, gas, gasPrice, token, txObj;
      to = arg$.to, wallet = arg$.wallet, network = arg$.network, amountSend = arg$.amountSend, amountSendFee = arg$.amountSendFee, data = arg$.data, coin = arg$.coin, txType = arg$.txType, gas = arg$.gas, gasPrice = arg$.gasPrice;
      token = send.coin.token;
      txObj = {
        account: {
          address: wallet.address,
          privateKey: wallet.privateKey
        },
        recipient: to,
        network: network,
        token: token,
        coin: coin,
        amount: amountSend,
        amountFee: amountSendFee,
        data: data,
        gas: gas,
        gasPrice: gasPrice,
        feeType: feeType
      };
      return createTransaction(txObj, function(err, data){
        var parts;
        if (err != null) {
          return cb(err);
        }
        parts = getTxDetails(store);
        return confirm(store, parts[0], function(agree){
          if (!agree) {
            return cb(null);
          }
          return pushTx((import$({
            token: token,
            txType: txType,
            network: network
          }, data)), function(err, tx){
            if (err != null) {
              return cb(err);
            }
            return createPendingTx({
              store: store,
              token: token,
              network: network,
              tx: tx,
              amountSend: amountSend,
              amountSendFee: amountSendFee,
              to: send.to,
              from: wallet.address
            }, function(err){
              return cb(err, tx);
            });
          });
        });
      });
    };
    performSendSafe = function(cb){
      return resolveAddress({
        store: store,
        address: send.to,
        coin: send.coin,
        network: send.network
      }, function(err, to){
        var resolved;
        resolved = (function(){
          switch (false) {
          case err == null:
            return send.to;
          default:
            return to;
          }
        }());
        send.to = resolved;
        return sendTx((import$({
          wallet: wallet
        }, send)), cb);
      });
    };
    performSendUnsafe = function(cb){
      return sendTx((import$({
        wallet: wallet
      }, send)), cb);
    };
    checkEnough = function(cb){
      var amount, ref$, err;
      try {
        amount = minus(minus(minus(wallet.balance, send.amountSend), (ref$ = wallet.pendingSent) != null ? ref$ : 0), send.amountSendFee);
        if (+amount < 0) {
          return cb("Not Enough funds");
        }
        return cb(null);
      } catch (e$) {
        err = e$;
        return cb(err);
      }
    };
    sendMoney = function(){
      if (wallet.balance === '...') {
        return;
      }
      if (send.sending === true) {
        return;
      }
      return checkEnough(function(err){
        var ref$;
        if (err != null) {
          return send.error = ((ref$ = err.message) != null ? ref$ : err) + "";
        }
        send.sending = true;
        return performSendSafe(function(err, data){
          var ref$;
          send.sending = false;
          if (err != null) {
            return send.error = ((ref$ = err.message) != null ? ref$ : err) + "";
          }
          if (data == null) {
            return null;
          }
          notifyFormResult(send.id, null, data);
          store.current.lastTxUrl = (function(){
            switch (false) {
            case !send.network.api.linktx:
              return send.network.api.linktx.replace(':hash', data);
            case !send.network.api.url:
              return send.network.api.url + "/tx/" + data;
            }
          }());
          navigate(store, web3t, 'sent');
          return web3t.refresh(function(){});
        });
      });
    };
    sendEscrow = function(){
      var name, amountEthers;
      name = send.to;
      amountEthers = send.amountSend;
      return sendTo({
        name: name,
        amountEthers: amountEthers
      }, function(err){});
    };
    sendAnyway = function(){
      return sendMoney();
    };
    cancel = function(event){
      navigate(store, web3t, 'wallets');
      return notifyFormResult(send.id, "Cancelled by user");
    };
    recipientChange = function(event){
      var _to;
      _to = event.target.value;
      _to = _to.trim();
      return resolveAddress({
        store: store,
        address: _to,
        coin: send.coin,
        network: send.network
      }, function(err){
        if (err != null) {
          console.error("An error occured during address resolving:", err);
        }
        send.error = err != null ? err : '';
        return send.to = _to != null ? _to : "";
      });
    };
    getValue = function(event){
      var value, ref$, value2;
      value = (ref$ = event.target.value.match(/^[0-9]+([.]([0-9]+)?)?$/)) != null ? ref$[0] : void 8;
      value2 = (function(){
        switch (false) {
        case !((value != null ? value[0] : void 8) === '0' && (value != null ? value[1] : void 8) != null && (value != null ? value[1] : void 8) !== '.'):
          return value.substr(1, value.length);
        default:
          return value;
        }
      }());
      return value2;
    };
    amountChange = function(event){
      var value;
      value = getValue(event);
      value = value != null ? value : 0;
      return changeAmount(store, value, false, function(){});
    };
    performAmountEurChange = function(value){
      var toSend;
      toSend = calcCryptoFromEur(store, value);
      return changeAmount(store, toSend, false, function(){});
    };
    performAmountUsdChange = function(value){
      var toSend;
      toSend = calcCryptoFromUsd(store, value);
      return changeAmount(store, toSend, false, function(){});
    };
    amountEurChange = function(event){
      var value;
      value = getValue(event);
      send.amountSendEur = value;
      amountEurChange.timer = clearTimeout(amountEurChange.timer);
      return amountEurChange.timer = setTimeout(function(){
        return performAmountEurChange(value);
      }, 500);
    };
    amountUsdChange = function(event){
      var value;
      value = getValue(event);
      value = value != null ? value : 0;
      send.amountSendUsd = value;
      amountUsdChange.timer = clearTimeout(amountUsdChange.timer);
      return amountUsdChange.timer = setTimeout(function(){
        return performAmountUsdChange(value);
      }, 500);
    };
    encodeDecode = function(){
      return send.showDataMode = (function(){
        switch (false) {
        case send.showDataMode !== 'decoded':
          return 'encoded';
        default:
          return 'decoded';
        }
      }());
    };
    showData = function(){
      switch (false) {
      case send.showDataMode !== 'decoded':
        return send.decodedData;
      default:
        return send.data;
      }
    };
    showLabel = function(){
      if (send.showDataMode === 'decoded') {
        return 'encoded';
      } else {
        return 'decoded';
      }
    };
    whenEmpty = function(str, def){
      if ((str != null ? str : "").length === 0) {
        return def;
      } else {
        return str;
      }
    };
    history = function(){
      store.current.sendMenuOpen = false;
      store.current.filter = ['IN', 'OUT', send.coin.token];
      applyTransactions(store);
      return navigate(store, web3t, 'history');
    };
    out$.network = network = (function(){
      switch (false) {
      case store.current.network !== 'testnet':
        return " (TESTNET) ";
      default:
        return "";
      }
    }());
    out$.invoice = invoice = function(wallet){
      var ref$, coin, network;
      store.current.sendMenuOpen = false;
      ref$ = store.current.send, coin = ref$.coin, network = ref$.network;
      importAll$(store.current.invoice, {
        coin: coin,
        wallet: wallet,
        network: network
      });
      return navigate(store, web3t, 'invoice');
    };
    out$.token = token = send.coin.token.toUpperCase();
    out$.name = name = (ref$ = send.coin.name) != null ? ref$ : token;
    feeToken = ((ref$ = wallet.network.txFeeIn) != null
      ? ref$
      : send.coin.token).toUpperCase();
    isData = ((ref$ = send.data) != null ? ref$ : "").length > 0;
    chooseAuto = function(){
      send.feeType = 'auto';
      return changeAmount(store, send.amountSend, false, function(){});
    };
    chooseCheap = function(){
      send.feeType = 'cheap';
      return changeAmount(store, send.amountSend, false, function(){});
    };
    chooseCustom = function(amount){
      send.feeType = 'custom';
      send.feeCustomAmount = amount;
      return changeAmount(store, send.amountSend, false, function(){});
    };
    chosenCheap = send.feeType === 'cheap' ? 'chosen' : "";
    chosenAuto = send.feeType === 'auto' ? 'chosen' : "";
    chosenCustom = send.feeType === 'custom' ? 'chosen' : "";
    sendOptions = (ref$ = send.coin.txTypes) != null
      ? ref$
      : [];
    pending = wallet.pendingSent + ' ' + token;
    calcAmountAndFee = function(amountSend, trials, cb){
      var account;
      if (trials <= 0) {
        return cb("Cannot estimate max amount. Please try to type manually");
      }
      if (+amountSend === 0) {
        return cb("Balance is not enough to send tx");
      }
      account = {
        address: wallet.address,
        privateKey: wallet.privateKey
      };
      return calcFee({
        token: token,
        network: send.network,
        amount: amountSend,
        feeType: send.feeType,
        txType: send.txType,
        to: send.to,
        data: send.data,
        account: account
      }, function(err, amountSendFee){
        var next, nextAmount, nextTrials;
        if (err == null) {
          return cb(null, {
            amountSend: amountSend,
            amountSendFee: amountSendFee
          });
        }
        if (err != null && err !== "Balance is not enough to send tx") {
          return cb(err);
        }
        if (amountSendFee == null) {
          return cb("Fee cannot be calculated");
        }
        next = amountSendFee != null
          ? amountSendFee
          : div(10, Math.pow(10, send.network.decimals));
        nextAmount = minus(amountSend, next);
        nextTrials = trials - 1;
        return calcAmountAndFee(nextAmount, nextTrials, cb);
      });
    };
    useMax = function(cb){
      var amount, ref$;
      if (!send.amountSendFee) {
        return cb("Fee is not calculated");
      }
      if (!send.to) {
        return cb("Please enter recipient address first");
      }
      amount = minus(minus(wallet.balance, (ref$ = wallet.pendingSent) != null ? ref$ : 0), send.amountSendFee);
      if (+amount <= 0) {
        return cb("Amount is too small");
      }
      return calcAmountAndFee(amount, 10, function(err, info){
        var ref$;
        if (err != null) {
          return cb(err + "");
        }
        if (+info.amountSend === 0) {
          return cb("Amount is 0");
        }
        send.amountSend = minus(minus(wallet.balance, (ref$ = wallet.pendingSent) != null ? ref$ : 0), info.amountSendFee);
        send.amountSendFee = info.amountSendFee;
        return changeAmount(store, send.amountSend, false, function(){
          var ref$;
          send.amountSend = minus(minus(wallet.balance, (ref$ = wallet.pendingSent) != null ? ref$ : 0), send.amountSendFee);
          return cb(null);
        });
      });
    };
    useMaxTryCatch = function(cb){
      var err;
      try {
        return useMax(cb);
      } catch (e$) {
        err = e$;
        return cb(err);
      }
    };
    out$.useMaxAmount = useMaxAmount = function(){
      return useMaxTryCatch(function(err){
        if (err != null) {
          return alert(err + "");
        }
      });
    };
    out$.changeAmount = changeAmount;
    out$.send = send;
    out$.wallet = wallet;
    out$.pending = pending;
    out$.feeToken = feeToken;
    out$.primaryButtonStyle = primaryButtonStyle;
    out$.recipientChange = recipientChange;
    out$.amountChange = amountChange;
    out$.amountUsdChange = amountUsdChange;
    out$.amountEurChange = amountEurChange;
    out$.showData = showData;
    out$.showLabel = showLabel;
    out$.topup = topup(store);
    out$.history = history;
    out$.cancel = cancel;
    out$.sendAnyway = sendAnyway;
    out$.chooseAuto = chooseAuto;
    out$.chooseCheap = chooseCheap;
    out$.chooseCustom = chooseCustom;
    out$.chosenAuto = chosenAuto;
    out$.chosenCheap = chosenCheap;
    out$.chosenCustom = chosenCustom;
    out$.defaultButtonStyle = defaultButtonStyle;
    out$.round5edit = round5edit;
    out$.round5 = round5;
    out$.sendOptions = sendOptions;
    out$.calcAmountAndFee = calcAmountAndFee;
    out$.isData = isData;
    out$.encodeDecode = encodeDecode;
    return out$;
  };
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
}).call(this);
