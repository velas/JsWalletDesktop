// Generated by LiveScript 1.6.0
(function(){
  var Eos, ref$, post, get, map, filter, foldl, plus, asCallback, apikey, listAccounts, calcFee, noAccount, getKeys, transformTx, getTransactions, getRandomInt, getRandomUrl, getNodeUrl, getEos, createTransaction, pushTx, getUnconfirmedBalance, checkTxStatus, getTotalReceived, getBalance, out$ = typeof exports != 'undefined' && exports || this, toString$ = {}.toString;
  Eos = require('eosjs');
  ref$ = require('./superagent.js'), post = ref$.post, get = ref$.get;
  ref$ = require('prelude-ls'), map = ref$.map, filter = ref$.filter, foldl = ref$.foldl;
  plus = require('../math.js').plus;
  asCallback = function(promise, cb){
    var state;
    state = {
      res: null,
      err: null
    };
    return promise.then(function(res){
      return state.res = res;
    })['catch'](function(err){
      return state.err = err;
    })['finally'](function(){
      return cb(state.err, state.res);
    });
  };
  apikey = 'a9564ebc3289b7a14551baf8ad5ec60a';
  listAccounts = function(arg$, cb){
    var network, publicKey, eos;
    network = arg$.network, publicKey = arg$.publicKey;
    eos = getEos({
      network: network
    });
    return asCallback(eos.getKeyAccounts(publicKey), function(err, data){
      var names, ref$;
      if (err != null) {
        return cb(err);
      }
      names = (ref$ = data.account_names) != null
        ? ref$
        : [];
      return cb(null, names);
    });
  };
  out$.calcFee = calcFee = function(arg$, cb){
    var network, tx;
    network = arg$.network, tx = arg$.tx;
    return cb(null);
  };
  noAccount = null;
  out$.getKeys = getKeys = function(arg$, cb){
    var network, mnemonic, index, ecc, privateKey, publicKey;
    network = arg$.network, mnemonic = arg$.mnemonic, index = arg$.index;
    ecc = Eos.modules.ecc;
    privateKey = ecc.seedPrivate(mnemonic + " " + index);
    publicKey = ecc.privateToPublic(privateKey);
    return listAccounts({
      network: network,
      publicKey: publicKey
    }, function(err, accounts){
      var address, ref$;
      if (err != null) {
        return cb(err);
      }
      address = (ref$ = accounts != null ? accounts[0] : void 8) != null ? ref$ : noAccount;
      return cb(null, {
        publicKey: publicKey,
        privateKey: privateKey,
        address: address
      });
    });
  };
  transformTx = curry$(function(network, t){
    var explorerUrl, dec, tx, amount, time, url, fee, from, to;
    explorerUrl = network.api.explorerUrl;
    dec = getDec(network);
    network = 'eos';
    tx = t.trx_id;
    amount = div(t.quantity, dec);
    time = t.timestamp;
    url = explorerUrl + "/tx/" + tx;
    fee = div(0, dec);
    from = t.sender;
    to = t.receiver;
    return {
      network: network,
      tx: tx,
      amount: amount,
      fee: fee,
      time: time,
      url: url,
      from: from,
      to: to
    };
  });
  out$.getTransactions = getTransactions = function(arg$, cb){
    var network, address, accountName;
    network = arg$.network, address = arg$.address;
    if (noAccount === address) {
      return cb(null, []);
    }
    accountName = address;
    return get(network.api.apiUrl + "/api?module=account&action=get_account_related_trx_info&apikey=" + apikey + "&account=" + accountName + "&page=1&size=2&transaction_type=3", function(err, data){
      var list, ref$, ref1$, transformed;
      if (err != null) {
        return cb(err);
      }
      if (data.body.errno !== 0) {
        return cb(data.text);
      }
      list = (ref$ = (ref1$ = data.body.data) != null ? ref1$.trace_list : void 8) != null
        ? ref$
        : [];
      transformed = map(transform(network))(
      list);
      return cb(null, transformed);
    });
  };
  getRandomInt = function(max){
    return Math.floor(Math.random() * Math.floor(max));
  };
  getRandomUrl = function(arr){
    var index;
    index = getRandomInt(arr.length);
    return arr[2];
  };
  getNodeUrl = function(nodeUrl){
    if (toString$.call(nodeUrl).slice(8, -1) === 'String') {
      return nodeUrl;
    }
    if (toString$.call(nodeUrl).slice(8, -1) === 'Array') {
      return getRandomUrl(nodeUrl);
    }
    return null;
  };
  getEos = function(arg$){
    var network, account, keyProvider, config;
    network = arg$.network, account = arg$.account;
    keyProvider = (function(){
      switch (false) {
      case (account != null ? account.privateKey : void 8) == null:
        return [account.privateKey];
      default:
        return null;
      }
    }());
    config = {
      chainId: network.chainId,
      keyProvider: keyProvider,
      httpEndpoint: getNodeUrl(network.api.nodeUrl),
      sign: keyProvider != null,
      broadcast: false,
      verbose: false
    };
    return Eos(config);
  };
  out$.createTransaction = createTransaction = function(arg$, cb){
    var network, account, recipient, amount, amountFee, data, feeType, txType, eos, broadcast, sign, from;
    network = arg$.network, account = arg$.account, recipient = arg$.recipient, amount = arg$.amount, amountFee = arg$.amountFee, data = arg$.data, feeType = arg$.feeType, txType = arg$.txType;
    if (account.address === noAccount) {
      return cb("Account is not registered");
    }
    eos = getEos({
      network: network,
      account: account
    });
    broadcast = false;
    sign = true;
    from = account.address;
    return asCallback(eos.transfer(from, recipient, amount, data, {
      broadcast: broadcast,
      sign: sign
    }), function(err, tr){
      return cb(null, tr.transaction);
    });
  };
  out$.pushTx = pushTx = curry$(function(arg$, cb){
    var network, rawtx, eos;
    network = arg$.network, rawtx = arg$.rawtx;
    eos = getEos({
      network: network
    });
    return asCallback(eos.pushTransaction(rawtx), function(err, data){
      if (err != null) {
        return cb(err);
      }
      return cb(null, data);
    });
  });
  out$.getUnconfirmedBalance = getUnconfirmedBalance = function(arg$, cb){
    var network, address;
    network = arg$.network, address = arg$.address;
    return cb("Not Implemented");
  };
  out$.checkTxStatus = checkTxStatus = function(arg$, cb){
    var network, tx;
    network = arg$.network, tx = arg$.tx;
    return cb("Not Implemented");
  };
  out$.getTotalReceived = getTotalReceived = function(arg$, cb){
    var address, network;
    address = arg$.address, network = arg$.network;
    return getTransactions({
      address: address,
      network: network
    }, function(err, txs){
      var total;
      total = foldl(plus, 0)(
      map(function(it){
        return it.amount;
      })(
      filter(function(it){
        return it.to === address;
      })(
      txs)));
      return cb(null, total);
    });
  };
  out$.getBalance = getBalance = function(arg$, cb){
    var network, address, accountName;
    network = arg$.network, address = arg$.address;
    if (address === noAccount) {
      return cb(null, 0);
    }
    accountName = address;
    return get(network.api.apiUrl + "/api?module=account&action=get_account_balance&apikey=" + apikey + "&account=" + accountName).end(function(err, data){
      var balance, ref$, ref1$;
      if (err != null) {
        return cb(err);
      }
      if (data.body.errno !== 0) {
        return cb(data.text);
      }
      balance = (ref$ = (ref1$ = data.body.data) != null ? ref1$.balance : void 8) != null ? ref$ : 0;
      return cb(null, balance);
    });
  };
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
