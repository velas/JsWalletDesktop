// Generated by LiveScript 1.6.0
(function(){
  var superagent, ref$, deriveKeypair, deriveAddress, generateSeed, big, hashjs, map, deadline, query, calcFee, getKeys, pushTx, getBalance, transformTx, getTransactions, getUnconfirmedBalance, checkTxStatus, getTotalReceived, createTransaction, out$ = typeof exports != 'undefined' && exports || this;
  superagent = require('./superagent.js');
  ref$ = require('ripple-keypairs'), deriveKeypair = ref$.deriveKeypair, deriveAddress = ref$.deriveAddress, generateSeed = ref$.generateSeed;
  big = require('big.js');
  hashjs = require('hash.js');
  map = require('prelude-ls').map;
  deadline = 15000;
  query = function(arg$, cb){
    var network, method, params, req;
    network = arg$.network, method = arg$.method, params = arg$.params;
    req = superagent.post(network.api.apiUrl).send({
      method: method,
      params: params
    });
    return req.timeout(deadline).end(function(err, res){
      var result;
      if (err != null) {
        return cb(err);
      }
      if (!res.body) {
        err = Error('no response');
        err.code = res.status;
      }
      if (res.status !== 200) {
        err = Error(res.body);
        err.code = res.status;
      }
      result = void 8;
      if (res.body.error) {
        err = Error(res.body.error);
        err.code = res.status;
        result = res.body;
      } else {
        result = res.body.result;
      }
      return cb && cb(err, result);
    });
  };
  out$.calcFee = calcFee = function(arg$, cb){
    var network, tx;
    network = arg$.network, tx = arg$.tx;
    return cb(null);
  };
  out$.getKeys = getKeys = function(arg$, cb){
    var network, mnemonic, index, entropy, secret, keypair, address;
    network = arg$.network, mnemonic = arg$.mnemonic, index = arg$.index;
    entropy = hashjs.sha512().update(mnemonic + " / " + index).digest().slice(0, 32);
    secret = generateSeed({
      entropy: entropy
    });
    keypair = deriveKeypair(secret);
    address = deriveAddress(keypair.publicKey);
    return cb(null, {
      address: address,
      secret: secret
    });
  };
  out$.pushTx = pushTx = curry$(function(arg$, cb){
    var rawtx, network, data;
    rawtx = arg$.rawtx, network = arg$.network;
    data = {
      method: 'submit',
      params: [{
        tx_blob: rawtx
      }],
      network: network
    };
    return query(data, function(err, res){
      if (err != null) {
        return cb(err);
      }
      return cb(null);
    });
  });
  out$.getBalance = getBalance = function(arg$, cb){
    var address;
    address = arg$.address;
    return get("https://data.ripple.com/v2/accounts/" + address + "/balances", function(err, data){
      return cb(err, data);
    });
  };
  transformTx = curry$(function(network, tx){
    return tx;
  });
  out$.getTransactions = getTransactions = function(arg$, cb){
    var address, network, account, data;
    address = arg$.address, network = arg$.network;
    account = address;
    data = {
      method: 'account_tx',
      params: [{
        account: account
      }],
      network: network
    };
    return query(data, function(err, res){
      var txs;
      if (err != null) {
        return cb(err);
      }
      txs = map(transformTx)(
      res.transactions);
      return cb(null, txs);
    });
  };
  out$.getUnconfirmedBalance = getUnconfirmedBalance = function(arg$, cb){
    var network, address;
    network = arg$.network, address = arg$.address;
    return cb("Not Implemented");
  };
  out$.checkTxStatus = checkTxStatus = function(arg$, cb){
    var network, tx;
    network = arg$.network, tx = arg$.tx;
    return cb("Not Implemented");
  };
  out$.getTotalReceived = getTotalReceived = function(arg$, cb){
    var address, network;
    address = arg$.address, network = arg$.network;
    return cb("Not Implemented");
  };
  out$.createTransaction = createTransaction = curry$(function(arg$, cb){
    var network, account, recipient, amount, amountFee, data, txType, tx_json, secret;
    network = arg$.network, account = arg$.account, recipient = arg$.recipient, amount = arg$.amount, amountFee = arg$.amountFee, data = arg$.data, txType = arg$.txType;
    tx_json = {
      Account: account.address,
      Destination: recipient,
      Amount: big(amount).mul(Math.pow(10, 6)).toFixed(),
      TransactionType: 'Payment'
    };
    secret = account.privateKey;
    data = {
      method: 'sign',
      params: [{
        secret: secret,
        tx_json: tx_json
      }],
      network: network
    };
    return query(data, function(err, res){
      if (err != null) {
        return cb(err);
      }
      return cb(null, res);
    });
  });
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
