// Generated by LiveScript 1.6.0
(function(){
  var ref$, map, split, filter, find, foldl, drop, take, sum, unique, div, times, plus, minus, bs58, Buffer, toBase58, toBuffer, SIMULATION_COUNT, EPOCHS_PER_YEAR, VALIDATOR_COUNT, asCallback, chooseRandomPool, simulateChooseValidators, simulateValidatorsStats, calcPoolsRewards, fillPools, queryPoolsWeb3t, queryPools, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};
  ref$ = require('prelude-ls'), map = ref$.map, split = ref$.split, filter = ref$.filter, find = ref$.find, foldl = ref$.foldl, drop = ref$.drop, take = ref$.take, sum = ref$.sum, unique = ref$.unique;
  ref$ = require('../math.js'), div = ref$.div, times = ref$.times, plus = ref$.plus, minus = ref$.minus;
  bs58 = require('bs58');
  Buffer = require('buffer').Buffer;
  toBase58 = function(obj){
    return bs58.encode(obj);
  };
  toBuffer = function(arr){
    if (arr instanceof Buffer) {
      return arr;
    } else {
      if (arr instanceof Uint8Array) {
        return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
      } else {
        return Buffer.from(arr);
      }
    }
  };
  SIMULATION_COUNT = 14600;
  EPOCHS_PER_YEAR = 1460;
  VALIDATOR_COUNT = 19;
  asCallback = function(p, cb){
    p['catch'](function(err){
      return cb(err);
    });
    return p.then(function(data){
      return cb(null, data);
    });
  };
  chooseRandomPool = function(pools){
    var totalStake, i$, len$, pool, point, i, counter;
    totalStake = 0;
    for (i$ = 0, len$ = pools.length; i$ < len$; ++i$) {
      pool = pools[i$];
      totalStake += parseFloat(pool.stake);
    }
    point = Math.random() * totalStake;
    if (+totalStake === 0) {
      return 0;
    }
    i = 0;
    counter = 0;
    while (counter < point) {
      counter += parseFloat(pools[i].stake);
      i++;
    }
    return i - 1;
  };
  simulateChooseValidators = function(pools){
    var poolsCopy, validators, i$, to$, i, poolIndex;
    poolsCopy = arrayFrom$(pools);
    validators = [];
    for (i$ = 1, to$ = VALIDATOR_COUNT; i$ <= to$; ++i$) {
      i = i$;
      if (poolsCopy.length === 0) {
        return validators;
      }
      poolIndex = chooseRandomPool(poolsCopy);
      validators.push(poolsCopy[poolIndex]);
      poolsCopy.splice(poolIndex, 1);
    }
    return validators;
  };
  simulateValidatorsStats = function(pools, count){
    var poolsCopy, i$, len$, pool, rewardsPerIndex, to$, i, validators, validatorsStake, validatorReward, j$, validator;
    poolsCopy = pools.filter(function(item){
      return item;
    }).map(function(item, index){
      var ref$;
      return ref$ = {}, import$(ref$, item), ref$.index = index, ref$;
    });
    for (i$ = 0, len$ = poolsCopy.length; i$ < len$; ++i$) {
      pool = poolsCopy[i$];
      if (pool.status !== 'active') {
        pool.stake = '0';
        pool.nodeStake = '0';
      }
    }
    rewardsPerIndex = [];
    for (i$ = 1, to$ = pools.length; i$ <= to$; ++i$) {
      i = i$;
      rewardsPerIndex.push({
        rewards: 0,
        validatorCount: 0
      });
    }
    for (i$ = 1; i$ <= count; ++i$) {
      i = i$;
      validators = simulateChooseValidators(poolsCopy);
      validatorsStake = validators.reduce(fn$, 0);
      validatorReward = 5 / 6147.368421052632 / 100 * validatorsStake / VALIDATOR_COUNT;
      for (j$ = 0, len$ = validators.length; j$ < len$; ++j$) {
        validator = validators[j$];
        rewardsPerIndex[validator.index].rewards += validatorReward;
        rewardsPerIndex[validator.index].validatorCount++;
      }
    }
    return rewardsPerIndex;
    function fn$(acc, curr){
      return acc + parseFloat(curr.stake);
    }
  };
  calcPoolsRewards = function(allPools){
    var stat, i$, to$, i, pool, nodeStake, totalStake, delegatorPart, nodePart;
    stat = simulateValidatorsStats(allPools, SIMULATION_COUNT);
    for (i$ = 0, to$ = allPools.length - 1; i$ <= to$; ++i$) {
      i = i$;
      pool = allPools[i];
      nodeStake = parseFloat(pool.nodeStake);
      totalStake = parseFloat(pool.stake);
      delegatorPart = Math.min(0.6, (totalStake - nodeStake) / totalStake);
      nodePart = 1 - delegatorPart;
      allPools[i].delegateReward = delegatorPart * stat[i].rewards / SIMULATION_COUNT * EPOCHS_PER_YEAR;
      allPools[i].nodeReward = nodePart * stat[i].rewards / SIMULATION_COUNT * EPOCHS_PER_YEAR;
      allPools[i].validatorProbability = stat[i].validatorCount / SIMULATION_COUNT;
    }
    return allPools;
  };
  fillPools = function(arg$, arg1$){
    var store, web3t, onProgress, onFinish, item, rest, stakingAddress, tokenAccountsFilter, ownerAddress;
    store = arg$.store, web3t = arg$.web3t, onProgress = arg$.onProgress, onFinish = arg$.onFinish;
    item = arg1$[0], rest = slice$.call(arg1$, 1);
    stakingAddress = store.staking.keystore.staking.address;
    if (item == null) {
      store.staking.allPoolsLoaded = true;
      store.staking.poolsAreLoading = false;
      return onFinish(null, []);
    }
    if (['validators', 'info'].indexOf(store.current.page) === -1) {
      store.staking.allPoolsLoaded = false;
      store.staking.poolsAreLoading = false;
      return onFinish(null, []);
    }
    item.stake = item.activatedStake;
    tokenAccountsFilter = {};
    ownerAddress = item.votePubkey;
    return asCallback(web3t.velas.NativeStaking.getInfo(), function(err, res){
      console.log(".getInfo", res);
      if (err != null) {
        return onFinish(err);
      }
      item.stakers = delegators.length + 1;
      item.miningAddress = '';
      return web3t.velas.BlockReward.validatorRewardPercent(item.address, function(err, validatorRewardPercent){
        if (err != null) {
          return onFinish(err);
        }
        item.validatorRewardPercent = div(validatorRewardPercent, 10000);
        return web3t.velas.ValidatorSet.isValidatorBanned(miningAddress, function(err, isValidatorBanned){
          if (err != null) {
            return onFinish(err);
          }
          return web3t.velas.Staking.stakeAmount(item.address, stakingAddress, function(err, amount){
            if (err != null) {
              return onFinish(err);
            }
            return web3t.velas.Staking.stakeAmount(item.address, item.address, function(err, nodeStake){
              if (err != null) {
                return onFinish(err);
              }
              return web3t.velas.Staking.orderedWithdrawAmount(item.address, stakingAddress, function(err, withdrawAmount){
                var status, onFinishLocal, onProgressLocal;
                if (err != null) {
                  return onFinish(err);
                }
                item.withdrawAmount = withdrawAmount;
                item.myStake = amount;
                status = (function(){
                  switch (false) {
                  case item.epochVoteAccount !== true:
                    return 'active';
                  case !isValidatorBanned:
                    return 'banned';
                  default:
                    return 'inactive';
                  }
                }());
                item.status = status;
                item.nodeStake = nodeStake;
                if (onProgress != null) {
                  onProgress([item].concat(arrayFrom$(rest)));
                }
                onFinishLocal = function(err, pools){
                  return onFinish(err, [item].concat(arrayFrom$(pools)));
                };
                onProgressLocal = function(pools){
                  return onProgress([item].concat(arrayFrom$(pools)));
                };
                return fillPools({
                  store: store,
                  web3t: web3t,
                  onProgress: onProgressLocal,
                  onFinish: onFinishLocal
                }, rest);
              });
            });
          });
        });
      });
    });
  };
  queryPoolsWeb3t = function(store, web3t, onProgress, onFinish){
    return asCallback(web3t.velas.NativeStaking.getStakingValidators(), function(err, result){
      var pools, allPools;
      if (err != null) {
        return cb(err);
      }
      pools = result;
      console.log("Validators are:", result);
      allPools = pools;
      store.staking.poolsAreLoading = true;
      return fillPools({
        store: store,
        web3t: web3t,
        onProgress: onProgress,
        onFinish: onFinish
      }, allPools);
    });
  };
  queryPools = function(store, web3t, onProgress, onFinish){
    return queryPoolsWeb3t(store, web3t, onProgress, function(err, pools){
      if (err != null) {
        return onFinish(err);
      }
      calcPoolsRewards(pools);
      return onFinish(err, pools);
    });
  };
  module.exports = {
    queryPools: queryPools
  };
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
